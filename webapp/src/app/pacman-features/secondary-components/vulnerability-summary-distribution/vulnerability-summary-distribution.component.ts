/*
 *Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); You may not use
 * this file except in compliance with the License. A copy of the License is located at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component, OnDestroy, Output, EventEmitter } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { environment } from './../../../../environments/environment';
import { LoggerService } from '../../../shared/services/logger.service';
import { AssetGroupObservableService } from '../../../core/services/asset-group-observable.service';
import { GridOptions } from 'ag-grid';
import * as _ from 'lodash';
import { VulnerabilitySummaryDistributionService } from '../../services/vulnerability-summary-distribution.service';

@Component({
  selector: 'app-vulnerability-summary-distribution',
  templateUrl: './vulnerability-summary-distribution.component.html',
  styleUrls: ['./vulnerability-summary-distribution.component.css'],
  providers: [VulnerabilitySummaryDistributionService, LoggerService]
})
export class VulnerabilitySummaryDistributionComponent implements OnDestroy {

  selectedAssetGroup: string;
  private errorMessage = 'apiResponseError';

  getContextMenuItems: any;
  gridApi: any;
  gridColumnApi: any;
  columns: any = [];
  initComplete = false;
  showtable = false;

  private gridOptions: GridOptions;
  private subscriptionToAssetGroup: Subscription;
  private dataSubscription: Subscription;

  @Output() errorOccurred = new EventEmitter();

  errorValue = 0;
  tabsData: any = [];
  selected: any;
  rowsData: any;
  tabsName: any;

  constructor(
          private assetGroupObservableService: AssetGroupObservableService,
          private logger: LoggerService,
          private vulnerabilitySummaryDistributionService: VulnerabilitySummaryDistributionService ) {

    this.gridOptions = <GridOptions>{};
    this.gridOptions.columnDefs = [];

    this.gridOptions.rowData = [];
        this.getContextMenuItems = function getContextMenuItems(params) {
            const result = [
              'toolPanel',
              'separator',
              'copy',
              'separator',
              'csvExport',
              'separator',
              'autoSizeAll',
              'resetColumns'
            ];
            return result;
        };

    this.subscriptionToAssetGroup = this.assetGroupObservableService.getAssetGroup().subscribe(
      assetGroupName => {
          this.showtable = false;
          this.selectedAssetGroup = assetGroupName;
          setTimeout(() => {
            this.showtable = true;
            this.resetPage();
            this.updateComponent();
          }, 10);
      });

  }

  resetPage() {
    this.tabsData = [];
    this.rowsData = [];
    }

  updateComponent() {
      this.errorValue = 0;
      this.getData();
  }

  getData() {

    if (this.dataSubscription) {
      this.dataSubscription.unsubscribe();
    }

    const payload = {};
    const queryParam = {
      'ag': this.selectedAssetGroup
    };
    this.errorValue = 0;

    const url = environment.openVulnerabilityTable.url;
    const method = environment.openVulnerabilityTable.method;

    this.dataSubscription = this.vulnerabilitySummaryDistributionService.getData(url, method, payload, queryParam).subscribe(
      response => {
      try {
        if (this.checkForEmptyData(response)) {
          this.errorOccurred.emit();
          this.errorValue = -1;
          this.errorMessage = 'vulnerabilityMessage';
        } else {
          this.errorValue = 1;
          this.processData(response);
        }

        } catch (e) {
        this.errorOccurred.emit();
        this.errorValue = -1;
        this.errorMessage = 'jsError';
        this.logger.log('error', e);
      }
    },
    error => {
      this.errorOccurred.emit();
      this.errorValue = -1;
      this.errorMessage = 'apiResponseError';
      this.logger.log('error', error);
    });
  }

  downloadCsv() {
    this.gridApi.exportDataAsCsv();
  }

  processData(data) {

    for (const key of Object.keys(data)) {
      this.tabsData.push({
        name: key,
        length: data[key].length
      });
    }


    this.selected = this.tabsData[0].name;
    this.rowsData = data;
    this.columns = [];
    const keys = Object.keys(data);
    const columns = Object.keys(data[keys[0]][0]);
    this.columns = columns;

    let eachObj = {};
    this.gridOptions.columnDefs = [];
    this.gridOptions.rowData = [];

   for ( let i = 0; i < columns.length; i++) {
    if (columns[i].toLowerCase() === 'name') {
      eachObj = {
        pinned: 'left',
        lockPosition: true,
        field: columns[i],
        headerName: columns[i],
        minWidth: 160,
        maxWidth: 800
      };
    } else {
      eachObj = {
        field: columns[i],
        headerName: columns[i],
        minWidth: 160,
        maxWidth: 800
      };
    }
    this.gridOptions.columnDefs.push(eachObj);
    }
    if (this.gridApi) {
      this.gridApi.setColumnDefs(this.gridOptions.columnDefs);
      this.setGridRowData();
      this.onresize();
    }
  }

  onGridReady(params) {
    this.gridApi = params.api;
    this.gridColumnApi = params.columnApi;
  }

  setGridRowData() {
    this.gridOptions.rowData = this.rowsData[this.selected];
    this.gridApi.setRowData(this.gridOptions.rowData);
  }

  onresize() {
    if (this.columns.length < 6 && this.columns.length > 0) {
      setTimeout(() => {
        this.gridApi.sizeColumnsToFit();
      }, 3);
    } else {
      this.autoSizeAll();
    }
  }

  autoSizeAll() {
    const allColumnIds = [];
    if (this.gridColumnApi) {
      this.gridColumnApi.getAllColumns().forEach(function(column) {
        allColumnIds.push(column.colId);
      });
      this.gridColumnApi.autoSizeColumns(allColumnIds);
    }
  }

  selectTab(tab, index) {
    if (tab === this.selected) {
        return;
    }

    const prevIndex = !!this.selected ? _.findIndex(this.tabsData, (tabData) => {
        return tabData === this.selected;
    }) + 1 : 0;

    this.selected = tab;
    this.setGridRowData();
  }

tabSelected(tab) {
    if (!this.selected) {
        return false;
    }
    return this.selected === tab;
}

checkForEmptyData(response) {
  let emptyResponse = true;
  const keys = Object.keys(response);
  for ( let index = 0; index < keys.length; index++) {
    if (response[keys[index]].length > 0) {
      emptyResponse = false;
      return emptyResponse;
    }
  }
  return emptyResponse;
}

ngOnDestroy() {
  try {
    if (this.subscriptionToAssetGroup) {
      this.subscriptionToAssetGroup.unsubscribe();
    }
    if (this.dataSubscription) {
      this.dataSubscription.unsubscribe();
    }
  } catch (error) {
    this.logger.log('error', '--- Error while unsubscribing ---');
  }
}


}
