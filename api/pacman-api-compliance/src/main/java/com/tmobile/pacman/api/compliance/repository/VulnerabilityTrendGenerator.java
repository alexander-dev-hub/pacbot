/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
/**
  Copyright (C) 2017 T Mobile Inc - All Rights Reserve
  Purpose:
  Author :kkumar
  Modified Date: Oct 20, 2017

 **/
package com.tmobile.pacman.api.compliance.repository;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.utils.PacHttpUtils;


/**
 * The Class VulnerabilityTrendGenerator.
 */
@Repository
public class VulnerabilityTrendGenerator implements Constants {

    /** The es host. */
    @Value("${elastic-search.host}")
    private String esHost;

    /** The es port. */
    @Value("${elastic-search.port}")
    private int esPort;

    /** The es cluster name. */
    @Value("${elastic-search.clusterName}")
    private String esClusterName;

    /** The date format. */
    @Value("${formats.date}")
    private String dateFormat;

    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory
            .getLogger(VulnerabilityTrendGenerator.class);

    /**
     * Generate trend.
     *
     * @param ag the ag
     * @param severity the severity
     * @param fromDate the from date
     * @return the list
     * @throws Exception the exception
     */

    public List<Map<String, Object>> generateTrend(String ag,String severity, Date fromDate) throws Exception {
        List<Map<String, Object>> dateList = new ArrayList<>();
        LocalDate from = LocalDate.parse(new SimpleDateFormat("yyyy-MM-dd").format(fromDate));

        StringBuilder queryBody = new StringBuilder();
        queryBody.append("\"query\":{\"bool\":{\"must\":[").
            append("{\"terms\":{\"severitylevel\":["+severity+"]}}").
            append("]}}");


        long totalCount = getTotalDocCount(ag,queryBody);

        if (totalCount > 0) {


            List<String> issueOpenDates = new ArrayList<>();
            ExecutorService executionService = Executors.newFixedThreadPool(2);
            Map<String,Long> newFoundMap = new HashMap<>();
            Map<String,Long> openCountMap = new HashMap<>();
            executionService.execute(()-> {
                newFoundMap.putAll(fetchNewlyFoundVulnByDay(ag,severity,from));
            });

            executionService.execute( () -> {

                // ES needs minimum 2 slices, if records are less , we need to slice
                // accordingly
                final int scrollSize = totalCount > 10000 ? 10000
                        : (int) (totalCount / 2) + 1;

                final int slices = totalCount > scrollSize ? (int) totalCount
                        / scrollSize + 1 : 2;

                IntStream.range(0, slices)
                        .parallel()
                        .forEach(i -> {
                            List<String> issueOpenDatesList = fetchVulnInfoDateRanges(ag,scrollSize,slices,i,queryBody,from);
                            synchronized(issueOpenDates){
                                issueOpenDates.addAll(issueOpenDatesList);
                            }
                         });

                openCountMap.putAll(issueOpenDates.parallelStream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())));

                });

            executionService.shutdown();
            while(!executionService.isTerminated()){}



            openCountMap.entrySet().forEach(entry->{
                Map<String,Object> dateObj = new HashMap<>();
                String date = entry.getKey();
                Long open = entry.getValue();
                Long newlyFound = newFoundMap.get(date);

                dateObj.put("date",date);
                dateObj.put("open",open);
                dateObj.put("new",newlyFound==null?0l:newlyFound);
                dateList.add(dateObj);

            });
            return dateList ;
        } else {

            throw new DataException(NO_DATA_FOUND);
        }
    }

    /**
     * Fetch newly found vuln by day.
     *
     * @param ag the ag
     * @param severity the severity
     * @param from the from
     * @return the map
     */
    private Map<String,Long> fetchNewlyFoundVulnByDay(String ag,String severity,LocalDate from ){

        StringBuilder queryBody = new StringBuilder();
        queryBody.append("\"query\":{\"bool\":{\"must\":[").
            append("{\"terms\":{\"severitylevel\":["+severity+"]}}").
            append(",{\"range\":{\"_firstFound\":{\"gte\":\"").
            append(from.toString()).
            append("\"}}}]}}");

        String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_search?size=0";
        StringBuilder request = new StringBuilder();
        request.append("{").
            append("\"aggs\":{\"dates\":{\"date_histogram\":{\"field\":\"_firstFound\",\"interval\":\"day\",\"format\":\"yyyy-MM-dd\"}}}").
            append(",").append(queryBody).append("}");

        Map<String,Long> newFoundMap = new HashMap<>();
        try {
            String searchResponse = PacHttpUtils.doHttpPost(searchUrl, request.toString());
            JsonParser parser = new JsonParser();
            JsonObject responeObj = parser.parse(searchResponse).getAsJsonObject();
            JsonArray dateBuckets = responeObj.getAsJsonObject("aggregations").getAsJsonObject("dates").getAsJsonArray("buckets");
            for(JsonElement jsonElement:dateBuckets){
                JsonObject dateObj = jsonElement.getAsJsonObject();
                newFoundMap.put(dateObj.get("key_as_string").getAsString(),dateObj.get("doc_count").getAsLong());

            }
        } catch (Exception e) {
            LOGGER.error("error",e);
        }

        return newFoundMap;

    }

    /**
     * Fetch vuln info date ranges.
     *
     * @param ag the ag
     * @param scrollSize the scroll size
     * @param slices the slices
     * @param sliceNo the slice no
     * @param queryBody the query body
     * @param from the from
     * @return the list
     */
    @SuppressWarnings("unchecked")
    private List<String> fetchVulnInfoDateRanges(String ag,int scrollSize,int slices,int sliceNo,StringBuilder queryBody,LocalDate from){
        String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_search?scroll=1m";
        StringBuilder request = new StringBuilder();
        request.append("{\"size\":").
        append(scrollSize).
        append(",\"_source\":[\"_firstFound\",\"_closedate\"],").
        append("\"slice\": {\"id\":").
        append(sliceNo).append(",\"max\":").append(slices).append("},").
        append(queryBody).append("}");
        try{
            String searchResponse = PacHttpUtils.doHttpPost(searchUrl, request.toString());
            JsonParser parser = new JsonParser();
            JsonObject responeObj = parser.parse(searchResponse).getAsJsonObject();
            JsonArray hits = responeObj.getAsJsonObject("hits").getAsJsonArray("hits");
            List<Map<String,Object>> hitsList = new Gson().fromJson(hits,new TypeToken<List<Map<String,Object>>>(){}.getType());
            return hitsList.parallelStream().map(obj-> (Map<String,Object>)obj.get("_source")).flatMap( obj-> getDateRange(obj.get("_firstFound"),obj.get("_closedate"),from).stream()).collect(Collectors.toList());

        }catch(Exception e){
            LOGGER.error("error",e);
        }
        return new ArrayList<>();

    }

    /**
     * Gets the total doc count.
     *
     * @param ag the ag
     * @param queryBody the query body
     * @return the total doc count
     * @throws Exception the exception
     */
    private long getTotalDocCount(String ag, StringBuilder queryBody) throws Exception{
        String countUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_count";
        StringBuilder requestBody = new StringBuilder();
        requestBody.append("{").append(queryBody).append("}");
        String countResponse = PacHttpUtils.doHttpPost(countUrl, requestBody.toString());
        JsonParser jsonParser = new JsonParser();
        JsonObject response = jsonParser.parse(countResponse).getAsJsonObject();
        return Double.valueOf(response.get("count").getAsString()).longValue();

    }

    /**
     * Gets the date range.
     *
     * @param from the from
     * @param to the to
     * @param excludeBefore the exclude before
     * @return the date range
     */
    private List<String> getDateRange(Object from, Object to, LocalDate excludeBefore){

        LocalDate fromDt;
        LocalDate toDt;
        List<String> dateRage = new ArrayList<>();
        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss[Z]['Z']");
        if(from!=null){
            fromDt = LocalDateTime.parse(from.toString(),inputFormatter).toLocalDate();
            if(to==null){
                toDt = LocalDate.now();
            }else{
                toDt = LocalDateTime.parse(to.toString(),inputFormatter).toLocalDate();
            }
            DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE;
            while(fromDt.isBefore(toDt)){
                if(!fromDt.isBefore(excludeBefore)){
                    dateRage.add(formatter.format(fromDt));
                }
                fromDt = fromDt.plusDays(1);
             }
        }

        return dateRage;
    }


}
