/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.pacman.api.compliance.service;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.exception.ServiceException;
import com.tmobile.pacman.api.commons.utils.CommonUtils;
import com.tmobile.pacman.api.compliance.client.AssetServiceClient;
import com.tmobile.pacman.api.compliance.domain.AssetApi;
import com.tmobile.pacman.api.compliance.domain.AssetApiData;
import com.tmobile.pacman.api.compliance.domain.AssetCount;
import com.tmobile.pacman.api.compliance.domain.AssetCountByAppEnvDTO;
import com.tmobile.pacman.api.compliance.domain.AssetCountDTO;
import com.tmobile.pacman.api.compliance.domain.AssetCountData;
import com.tmobile.pacman.api.compliance.domain.Request;
import com.tmobile.pacman.api.compliance.domain.TrendNote;
import com.tmobile.pacman.api.compliance.repository.VulnerabilityRepository;
import com.tmobile.pacman.api.compliance.repository.VulnerabilityTrendGenerator;

/**
 * The Class VulnerabilityService.
 */
@Service
public class VulnerabilityService implements Constants {

    /** The vulnerability repository. */
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;
    
    /** The vuln trend generator. */
    @Autowired
    VulnerabilityTrendGenerator vulnTrendGenerator;
    
    @Autowired
    ComplianceService complianceService;

    /** The vuln types. */
    @Value("${vulnerability.types}")
    private String vulnTypes;

    /** The vuln summary severity. */
    @Value("${vulnerability.summary.severity}")
    private String vulnSummarySeverity;
    
    /** The asset service client. */
    @Autowired
    private AssetServiceClient assetServiceClient;

    /** The Constant logger. */
    private static final Log logger = LogFactory.getLog(VulnerabilityService.class);

   

    /**
     * Gets the vulnerabilities details.
     *
     * @param assetGroup the asset group
     * @param filter the filter
     * @return the vulnerabilities details
     * @throws Exception the exception
     */
    public List<Map<String, Object>> getVulnerabilitiesDetails(
            String assetGroup, Map<String, String> filter) throws Exception {
        List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<>();
        try {
            List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
            if (!vulnTargetTypes.isEmpty()) {
                for (String parentType : vulnTargetTypes) {
                    Map<String, Long> vulnAssetsAffected = vulnerabilityRepository
                            .getAssetsAffectedCount(assetGroup, filter,
                                    parentType);
                    List<Map<String, Object>> vulnerabilitiesData = formVulnerabilitiesData(
                            vulnerabilityRepository.getAllVulnerabilities(new ArrayList<String>(
                                    vulnAssetsAffected.keySet())), vulnAssetsAffected);
                    List<Map<String,Object>> vulnerabilitiesDetailsTemp = new ArrayList<>();
                    if(vulnerabilitiesDetails.isEmpty()) {
                        vulnerabilitiesDetails = new ArrayList<>(vulnerabilitiesData);
                    } else {
                        for(Map<String,Object> vulnData : vulnerabilitiesData) {
                            boolean qidMatched = false;
                            for(Map<String,Object> vulnDetail : vulnerabilitiesDetails) {
                                if(vulnData.get("qid").equals(vulnDetail.get("qid"))) {
                                    vulnDetail.put(ASSETS_AFFECTED, Long.valueOf(vulnDetail.get(ASSETS_AFFECTED).toString())
                                            + Long.valueOf(vulnData.get(ASSETS_AFFECTED).toString()));
                                    qidMatched = true;
                                    break;
                                }
                            }
                            if(!qidMatched) {
                                vulnerabilitiesDetailsTemp.add(vulnData);
                            }
                        }
                        vulnerabilitiesDetails.addAll(vulnerabilitiesDetailsTemp);
                    }
                }
            }

        } catch (Exception e) {
            logger.error("Error in getVulnerabilitiesDetails ", e);
            throw e;
        }

        return vulnerabilitiesDetails;
    }

    /**
     * Gets the vulnerability summary.
     *
     * @param assetGroup the asset group
     * @return the vulnerability summary
     * @throws ServiceException the service exception
     */
    @SuppressWarnings({ "unchecked" })
    public Map<String, Object> getVulnerabilitySummary(String assetGroup,String reqSeverity)
            throws ServiceException {
        
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

        Map<String, Object> vulnerabilitySummary = new HashMap<>();
        List<Map<String, Object>> severityInfo = new ArrayList<>();
        if (vulnTargetTypes.isEmpty()) {
            for (int i = 3; i <= 5; i++) {
                Map<String, Object> sevInfo = new HashMap<>();
                sevInfo.put(SEVERITY, "S" + i);
                sevInfo.put(SEVEITY_LEVEL, i);
                sevInfo.put(COUNT, 0);
                sevInfo.put("appCount", 0);
                sevInfo.put("hostCount", 0);
                sevInfo.put(UNIQUE_VULN_COUNT, 0);
                sevInfo.put(VULN_COUNT, 0);
                severityInfo.add(sevInfo);
            }
            vulnerabilitySummary.put(SEV_INFO, severityInfo);
            vulnerabilitySummary.put(VULNEREBILITIES, 0);
            vulnerabilitySummary.put("hosts", 0);
            vulnerabilitySummary.put(TOTAL_VULN_ASSETS, 0);
            vulnerabilitySummary.put("compliantpercent", 100);
            vulnerabilitySummary.put("assetsWithVulns", 0);
            return vulnerabilitySummary;

        } else {

            Map<String,Map<String,Object>> queryResults = new HashMap<>();
            
            long totalQualysCount = 0;
            long vulnerableAssetCount = 0;
            long totalAssetCount = 0;
         
            ExecutorService executor = Executors.newFixedThreadPool(3);
            executor.execute(() -> {
                queryResults.put("uniqueHost",vulnerabilityRepository.getUniqueHost(assetGroup,reqSeverity));
            });
            executor.execute(() -> {
                queryResults.put("VulnInfo",vulnerabilityRepository.getVulnInfo(assetGroup,reqSeverity));
                
            });
            executor.execute(() -> {
                queryResults.put("uniqueApp",vulnerabilityRepository.getUniqueApp(assetGroup));
            });
            executor.shutdown();
            while (!executor.isTerminated()) {
            }

            Map<String,Object> uniqueHost = queryResults.get("uniqueHost");
            Map<String,Object> vulnInfo = queryResults.get("VulnInfo");
            Map<String,Object> uniqueApp = queryResults.get("uniqueApp");
            
            List<String> sevList = Arrays.asList(reqSeverity.split(","));
            List<String> summarySevList = Arrays.asList(vulnSummarySeverity.split(",")); 
            Map<String,Object> sevVulnInfo ;
            Map<String,Object> vulnInfoMap ;
            
            List<Map<String, Object>> sevVulnfoList = new ArrayList<>();
            vulnerabilitySummary.put(SEV_INFO, sevVulnfoList);
            
            for(String sev : sevList){
                sevVulnInfo = new HashMap<>();
                sevVulnInfo.put(SEVEITY_LEVEL, Integer.valueOf(sev));
                sevVulnInfo.put(SEVERITY, "S"+sev);
                sevVulnInfo.put("hostCount", uniqueHost.get(sev)==null?0:uniqueHost.get(sev));
                if(summarySevList.contains(sev)){
                    vulnerableAssetCount += Long.valueOf(sevVulnInfo.get("hostCount").toString());
                }
                vulnInfoMap = (Map<String, Object>) vulnInfo.get(sev);
                if(vulnInfoMap!=null){
                    sevVulnInfo.put(COUNT,vulnInfoMap.get(VULN_COUNT));
                    sevVulnInfo.put(VULN_COUNT,vulnInfoMap.get(VULN_COUNT));
                    sevVulnInfo.put(UNIQUE_VULN_COUNT,vulnInfoMap.get(UNIQUE_VULN_COUNT));
                }else{
                    sevVulnInfo.put(COUNT,0);
                    sevVulnInfo.put(VULN_COUNT,0);
                    sevVulnInfo.put(UNIQUE_VULN_COUNT,0);
                }
                sevVulnInfo.put("appCount", uniqueApp.get(sev)==null?0:uniqueApp.get(sev));
                sevVulnfoList.add(sevVulnInfo);
            }
            vulnerabilitySummary.put(UNIQUE_VULN_COUNT, sevVulnfoList.stream().mapToLong(sevData-> Long.valueOf(sevData.get(UNIQUE_VULN_COUNT).toString())).sum());
            vulnerabilitySummary.put("assetsWithVulns", uniqueHost.get(TOTAL)==null?0:uniqueHost.get(TOTAL));
            vulnerabilitySummary.put( VULNEREBILITIES,vulnInfo.get(TOTAL)==null?0:vulnInfo.get(TOTAL));
            
            if(sevList.stream().filter(summarySevList::contains).count() != summarySevList.size()){
                vulnerableAssetCount = Long.valueOf(vulnerabilityRepository.getUniqueHost(assetGroup,vulnSummarySeverity).get(TOTAL).toString());
            }
            
            for (String vulnType : vulnTargetTypes) {
                try{
                    if(vulnType.equals(EC2)) {
                        Request request = new Request();
                        request.setAg(assetGroup);
                        Map<String, String> filter = new HashMap<>();
                        filter.put("domain", "Infra & Platforms");
                        filter.put("ruleId.keyword","PacMan_Ec2InstanceScannedByQualys_version-1_Ec2-instance-scanned-by-qualys-API_ec2");
                        request.setFilter(filter );
                        Map<String, Object> response = complianceService.getRulecompliance(request).getResponse().get(0);
                        totalAssetCount += Long.valueOf(response.get("assetsScanned").toString());
                        totalQualysCount += Long.valueOf(response.get("passed").toString());
                    } else {
                        AssetCount totalAssets = assetServiceClient
                                .getTotalAssetsCount(assetGroup, vulnType, null);
                        AssetCountData data = totalAssets.getData();
                        AssetCountByAppEnvDTO[] assetcount = data.getAssetcount();
                        Long totalAssetsCount = 0l;
                        for (AssetCountByAppEnvDTO assetCount_Count : assetcount) {
                            if (assetCount_Count.getType().equalsIgnoreCase(vulnType)) {
                                totalAssetsCount = Long.parseLong(assetCount_Count
                                        .getCount());
                            }
                        }
                        totalAssetCount += totalAssetsCount;
                        totalQualysCount += vulnerabilityRepository.getTotalQualysHostCount(assetGroup, vulnType);
                    }
              }catch(ServiceException | DataException e){
                  throw new ServiceException();
              }
            }

            try {
               
                vulnerabilitySummary.put("hosts", totalAssetCount);
                if (totalQualysCount > totalAssetCount) {
                    totalQualysCount = totalAssetCount;
                }

                long totalVulnerableAssets = totalAssetCount - totalQualysCount
                        + vulnerableAssetCount;
                if (totalVulnerableAssets > totalAssetCount) {
                    totalVulnerableAssets = totalAssetCount;
                }
                vulnerabilitySummary.put(TOTAL_VULN_ASSETS,
                        totalVulnerableAssets);
                
                float compliantCount = (float)totalAssetCount - totalVulnerableAssets;
                float compliantpercent = 100;
                if (totalAssetCount > 0) {
                    compliantpercent = (compliantCount / totalAssetCount) * 100;
                }
                DecimalFormat df = new DecimalFormat("#.00");
                vulnerabilitySummary.put("compliantpercent",
                        Math.floor(Float.valueOf(df.format(compliantpercent))));
                vulnerabilitySummary.put("hostsScanned", totalQualysCount);
                vulnerabilitySummary.put("hostsNotScanned", totalAssetCount-totalQualysCount);
                if(totalAssetCount > 0) {
                    vulnerabilitySummary.put("hostsScanCoverage", Math.floor( (1.0*totalQualysCount/totalAssetCount)*100));
                } else {
                    vulnerabilitySummary.put("hostsScanCoverage", 0);
                }
            } catch (Exception e) {
                logger.error(e);
                throw new ServiceException(e);
            }
            if(vulnerabilitySummary.isEmpty()){
                throw new ServiceException(NO_DATA_FOUND);
            }
            return vulnerabilitySummary;
        }
       
    }

    /**
     * Gets the vulnerability by app and env.
     *
     * @param assetGroup the asset group
     * @param filter the filter
     * @param application the application
     * @return the vulnerability by app and env
     * @throws Exception the exception
     */
    public List<Map<String, Object>> getVulnerabilityByAppAndEnv(
            String assetGroup, String filter, String application)
            throws Exception {

        List<Map<String, Object>> vulnApplications = new ArrayList<>();
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

        if (!vulnTargetTypes.isEmpty()) {
            for (String parentType : vulnTargetTypes) {
                vulnApplications.addAll(vulnerabilityRepository
                        .getVulnerabilyAcrossAppAndEnv(assetGroup, filter,
                                application, parentType, null));
            }
        }

        return vulnApplications;
    }

    /**
     * Gets the vulnerability trend.
     *
     * @param assetGroup the asset group
     * @param filter the filter
     * @param from the from
     * @param to the to
     * @return the vulnerability trend
     * @throws Exception the exception
     */
    public List<Map<String, Object>> getVulnerabilityTrend(String assetGroup,
            Map<String, String> filter, Date from, Date to) throws Exception {
        return vulnerabilityRepository.getVulnerabilityTrend(assetGroup,
                filter, from, to);
    }
    
    /**
     * Gets the vulnerability trend.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @param from the from
     * @return the vulnerability trend with open new count
     * @throws Exception the exception
     */
    public List<Map<String, Object>> getVulnerabilityNewOpenTrend(String assetGroup,
           String severity, Date from) throws Exception {
        return vulnTrendGenerator.generateTrend(assetGroup,
                severity,from);
    }
    

    /**
     * Gets the vulnerabilities distribution.
     *
     * @param assetGroup the asset group
     * @return the vulnerabilities distribution
     * @throws Exception the exception
     */
    public List<Map<String, Object>> getVulnerabilitiesDistribution(
            String assetGroup) throws Exception {

        List<Map<String, Object>> vulnDistributions = new ArrayList<>();
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
        if (!vulnTargetTypes.isEmpty()) {
            for (String parentType : vulnTargetTypes) {
                vulnDistributions
                        .addAll(vulnerabilityRepository
                                .getVulnerabilitiesDistribution(assetGroup,
                                        parentType));
            }
        }
        return vulnDistributions;
    }

    /**
     * Filter matching collection elements.
     *
     * @param masterDetailList the master detail list
     * @param searchText the search text
     * @param b the b
     * @return the object
     * @throws ServiceException the ServiceException
     */
    public Object filterMatchingCollectionElements(
            List<Map<String, Object>> masterDetailList, String searchText,
            boolean b) throws ServiceException {
        return CommonUtils.filterMatchingCollectionElements(masterDetailList,
                searchText, true);
    }

    /**
     * Gets the vulnerabilitysummary by resource id.
     *
     * @param instanceId the instance id
     * @return the vulnerabilitysummary by resource id
     */
    public Map<String, Object> getVulnerabilitysummaryByResourceId(
            String instanceId) {
        return vulnerabilityRepository
                .getVulnerabilitysummaryByResourceId(instanceId);
    }

    /**
     * Gets the vulnerability details by resource id.
     *
     * @param instanceId the instance id
     * @return the vulnerability details by resource id
     */
    public List<Map<String, Object>> getVulnerabilityDetailsByResourceId(
            String instanceId) {

        List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<>();
        try {
            List<Map<String, Object>> vulnerabilitiesDetailsList = vulnerabilityRepository
                    .getVulnerabilityDetailsByResourceId(instanceId);
            vulnerabilitiesDetails = formVulnerabilitiesData(
                    vulnerabilitiesDetailsList, new HashMap<String, Long>());
        } catch (Exception e) {
            logger.error("Error in getVulnerabilitiesDetails ", e);
            throw e;
        }

        return vulnerabilitiesDetails;
    }

    /**
     * Form vulnerabilities data.
     *
     * @param vulnerabilitiesDetails the vulnerabilities details
     * @param vulnAssetsAffected the vuln assets affected
     * @return the list
     */
    private List<Map<String, Object>> formVulnerabilitiesData(
            List<Map<String, Object>> vulnerabilitiesDetails,
            Map<String, Long> vulnAssetsAffected) {

        List<Map<String, Object>> vulnerabilitiesDetailsList = new ArrayList<>();

        vulnerabilitiesDetails
                .parallelStream()
                .forEach(
                        vulnObject -> {
                            Map<String, Object> vulnObj = new LinkedHashMap<>();
                            vulnObj.put(TITLE, vulnObject.get(TITLE).toString());
                            vulnObj.put(
                                    SEVERITY,
                                    "S"
                                            + Double.valueOf(
                                                    vulnObject.get(
                                                            SEVEITY_LEVEL)
                                                            .toString())
                                                    .intValue());
                            if (!CollectionUtils.isEmpty(vulnAssetsAffected)) {
                                vulnObj.put(ASSETS_AFFECTED, vulnAssetsAffected
                                        .get(String.valueOf(vulnObject.get(
                                                "qid").toString())));
                            }
                            vulnObj.put(
                                    "qid",
                                    Double.valueOf(
                                            vulnObject.get("qid").toString())
                                            .longValue());
                            vulnObj.put(CATEGORY, vulnObject.get(CATEGORY)
                                    .toString());
                            vulnObj.put(VULN_TYPE, vulnObject.get(VULN_TYPE)
                                    .toString());
                            if (vulnObject.containsKey(PATCHABLE)) {
                                vulnObj.put(PATCHABLE, "1".equals(vulnObject
                                        .get(PATCHABLE).toString()) ? true
                                        : false);
                            }
                            vulnObj.put(
                                    SEVEITY_LEVEL,
                                    Double.valueOf(
                                            vulnObject.get(SEVEITY_LEVEL)
                                                    .toString()).intValue());
                            synchronized (vulnerabilitiesDetailsList) {
                                vulnerabilitiesDetailsList.add(vulnObj);
                            }
                        });

        if (!CollectionUtils.isEmpty(vulnAssetsAffected)) {
            return vulnerabilitiesDetailsList
                    .stream()
                    .sorted((h1, h2) -> (int) (Double.parseDouble(h2.get(
                            ASSETS_AFFECTED).toString()) - (Double
                            .parseDouble(h1.get(ASSETS_AFFECTED).toString()))))
                    .sorted((h1, h2) -> (int) (Double.parseDouble(h2.get(
                            SEVEITY_LEVEL).toString()) - (Double.parseDouble(h1
                            .get(SEVEITY_LEVEL).toString()))))
                    .collect(Collectors.toList());
        } else {
            return vulnerabilitiesDetailsList
                    .stream()
                    .sorted((h1, h2) -> (int) (Double.parseDouble(h2.get(
                            SEVEITY_LEVEL).toString()) - (Double.parseDouble(h1
                            .get(SEVEITY_LEVEL).toString()))))
                    .collect(Collectors.toList());
        }

    }

    /**
     * Gets the target types.
     *
     * @param assetGroup the asset group
     * @return the target types
     */
    private String getTargetTypes(String assetGroup) {
        String tTypesTemp;
        String ttypes = null;
        AssetApi assetApi = assetServiceClient.getTargetTypeList(assetGroup,
                null);
        AssetApiData data = assetApi.getData();
        AssetCountDTO[] targetTypes = data.getTargettypes();
        for (AssetCountDTO name : targetTypes) {
            if (!Strings.isNullOrEmpty(name.getType())) {
                tTypesTemp = new StringBuilder().append('\'')
                        .append(name.getType()).append('\'').toString();
                if (Strings.isNullOrEmpty(ttypes)) {
                    ttypes = tTypesTemp;
                } else {
                    ttypes = new StringBuilder(ttypes).append(",").append(tTypesTemp).toString();
                }
            }
        }
        return ttypes;
    }

    /**
     * Gets the vulnerability distribution summary.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the vulnerability distribution summary
     */
    public List<Map<String, Object>> getVulnerabilityDistributionSummary(
            String assetGroup, String severity) {
        
        List<Map<String, Object>> distributionSummary = new ArrayList<>();
        
        Map<String, Map<String, Object>> appDetails = getDistributionSummary(assetGroup, severity);
        
        Map<String, String> directApp = new ConcurrentHashMap<>();
        Map<String, String> vpApp = new ConcurrentHashMap<>();
        formDirectorAndVPByApp(directApp, vpApp);
        
        if (StringUtils.isEmpty(severity)) {
            for (int i = 3; i <= 5; i++) {
                distributionSummary.add(formDistributionSummary(appDetails,
                        directApp, vpApp, String.valueOf(i)));
            }
        } else
            distributionSummary.add(formDistributionSummary(appDetails,
                    directApp, vpApp, severity));

        return distributionSummary;
    }

    /**
     * Form distribution summary.
     *
     * @param appDetails the app details
     * @param directApp the direct app
     * @param vpApp the vp app
     * @param severity the severity
     * @return the map
     */
    private Map<String, Object> formDistributionSummary(
            Map<String, Map<String, Object>> appDetails,
            Map<String, String> directApp, Map<String, String> vpApp,
            String severity) {

        List<Map<String, Object>> vpData = new ArrayList<>();
        List<Map<String, Object>> directorData = new ArrayList<>();
        List<Map<String, Object>> appData = new ArrayList<>();

        int total = 0;

        for (Entry<String, Map<String, Object>> entry : appDetails.entrySet()) {
            String appName = entry.getKey();
            Map<String, Object> sev = entry.getValue();

            Map<String, Object> appTemp = new HashMap<>();
            appTemp.put("name", appName);
            appTemp.put(COUNT, sev.get("S" + severity));
            total += Integer.valueOf(sev.get("S" + severity).toString());
            appData.add(appTemp);
            if (!directorData.isEmpty()) {
                String director;
                if (StringUtils.isEmpty(directApp.get(appName)))
                    director = UNKNOWN;
                else
                    director = directApp.get(appName);

                boolean directorExists = false;
                for (Map<String, Object> existingDirectorData : directorData) {
                    if (director.equals(existingDirectorData.get("name"))) {
                        existingDirectorData.put(
                                COUNT,
                                Integer.valueOf(existingDirectorData.get(COUNT)
                                        .toString())
                                        + Integer.valueOf(sev.get(
                                                "S" + severity).toString()));
                        directorExists = true;
                        break;
                    }
                }
                if (!directorExists) {
                    Map<String, Object> directorTemp = new HashMap<>();
                    directorTemp.put("name", director);
                    directorTemp.put(COUNT, sev.get("S" + severity));
                    directorData.add(directorTemp);
                }
            } else {
                Map<String, Object> directorTemp = new HashMap<>();
                if (StringUtils.isEmpty(directApp.get(appName))) {
                    directorTemp.put("name", UNKNOWN);
                } else
                    directorTemp.put("name", directApp.get(appName));
                directorTemp.put(COUNT, sev.get("S" + severity));
                directorData.add(directorTemp);
            }

            if (!vpData.isEmpty()) {
                String vp;
                if (StringUtils.isEmpty(vpApp.get(appName)))
                    vp = UNKNOWN;
                else
                    vp = vpApp.get(appName);

                boolean vpExists = false;
                for (Map<String, Object> existingVpData : vpData) {
                    if (vp.equals(existingVpData.get("name"))) {
                        existingVpData.put(
                                COUNT,
                                Integer.valueOf(existingVpData.get(COUNT)
                                        .toString())
                                        + Integer.valueOf(sev.get(
                                                "S" + severity).toString()));
                        vpExists = true;
                        break;
                    }
                }
                if (!vpExists) {
                    Map<String, Object> vpTemp = new HashMap<>();
                    vpTemp.put("name", vp);
                    vpTemp.put(COUNT, sev.get("S" + severity));
                    vpData.add(vpTemp);
                }
            } else {
                Map<String, Object> vpTemp = new HashMap<>();
                if (StringUtils.isEmpty(vpApp.get(appName))) {
                    vpTemp.put("name", UNKNOWN);
                } else
                    vpTemp.put("name", vpApp.get(appName));
                vpTemp.put(COUNT, sev.get("S" + severity));
                vpData.add(vpTemp);
            }
        }

        Map<String, Object> vpInfo = new LinkedHashMap<>();
        vpInfo.put("type", "VP");
        vpInfo.put("data", vpData);
        Map<String, Object> directorInfo = new LinkedHashMap<>();
        directorInfo.put("type", "Director");
        directorInfo.put("data", directorData);
        Map<String, Object> appInfo = new LinkedHashMap<>();
        appInfo.put("type", "Application");
        appInfo.put("data", appData);

        List<Map<String, Object>> distributionList = new ArrayList<>();
        distributionList.add(vpInfo);
        distributionList.add(directorInfo);
        distributionList.add(appInfo);

        Map<String, Object> severityMap = new HashMap<>();
        severityMap.put(SEVERITY, Integer.valueOf(severity));
        severityMap.put("distribution", distributionList);
        severityMap.put("total", total);
        return severityMap;
    }

    /**
     * Gets the aging summary.
     *
     * @param assetGroup the asset group
     * @return the aging summary
     */
    public List<Map<String, Object>> getAgingSummary(String assetGroup) {
        return vulnerabilityRepository.getAgingSummary(assetGroup);
    }

    /**
     * Gets the aging distribution summary.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the aging distribution summary
     */
    @SuppressWarnings("unchecked")
    public List<Map<String, Object>> getAgingDistributionSummary(
            String assetGroup, String severity) {

        List<Map<String, Object>> distributionSummary = new ArrayList<>();
        List<Map<String, Object>> vulnApplications = new ArrayList<>();
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
        if (!vulnTargetTypes.isEmpty()) {
            for (String parentType : vulnTargetTypes) {
                try {
                    vulnApplications.addAll(vulnerabilityRepository
                            .getAgingByApplication(assetGroup, parentType,
                                    severity));
                } catch (Exception e) {
                    logger.error(e);
                }
            }
        }
        /* Parallel Stream and so concurrent hashmap */
        Map<String, String> directApp = new ConcurrentHashMap<>();
        Map<String, String> vpApp = new ConcurrentHashMap<>();
        try {
            vulnerabilityRepository
                    .fetchExecDirectorApps()
                    .parallelStream()
                    .forEach(
                            app -> {
                                directApp.put(app.get(APP_TAG).toString(), app
                                        .get("director").toString());
                                vpApp.put(app.get(APP_TAG).toString(),
                                        app.get("executiveSponsor").toString());
                            });

        } catch (Exception e) {
            logger.error(e);
        }

        Map<String, Object> appDetails = new ConcurrentHashMap<>();
        vulnApplications
                .parallelStream()
                .forEach(
                        vulnApps -> {
                            List<Map<String, Object>> severityInfo = (List<Map<String, Object>>) vulnApps
                                    .get(SEV_INFO);
                            Map<String, Map<String, Object>> sevDetails = new HashMap<>();
                            for (Map<String, Object> sevInfo : severityInfo) {
                                Map<String, Object> days = new HashMap<>();
                                days.put("days", sevInfo.get("days"));
                                days.put(COUNT, sevInfo.get(COUNT));
                                sevDetails.put(
                                        sevInfo.get(SEVERITY).toString(), days);
                            }
                            appDetails.put(vulnApps.get("application")
                                    .toString(), sevDetails);
                        });
        if (StringUtils.isEmpty(severity)) {
            for (int i = 3; i <= 5; i++) {
                distributionSummary.add(formAgingDistributionSummary(
                        appDetails, directApp, vpApp, String.valueOf(i)));
            }
        } else
            distributionSummary.add(formAgingDistributionSummary(appDetails,
                    directApp, vpApp, severity));

        return distributionSummary;
    }

    /**
     * Form aging distribution summary.
     *
     * @param appDetails the app details
     * @param directApp the direct app
     * @param vpApp the vp app
     * @param severity the severity
     * @return the map
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> formAgingDistributionSummary(
            Map<String, Object> appDetails, Map<String, String> directApp,
            Map<String, String> vpApp, String severity) {

        List<Map<String, Object>> vpData = new ArrayList<>();
        List<Map<String, Object>> directorData = new ArrayList<>();
        List<Map<String, Object>> appData = new ArrayList<>();

        ObjectMapper oMapper = new ObjectMapper();

        for (Entry<String, Object> entry : appDetails.entrySet()) {
            String appName = entry.getKey();
            Map<String, Object> sev = oMapper.convertValue(entry.getValue(),
                    Map.class);
            Map<String, Object> appTemp = new HashMap<>();
            appTemp.put("name", appName);
            Map<String, Object> sevInfo = oMapper.convertValue(
                    sev.get("S" + severity), Map.class);
            if (sevInfo.get(COUNT).toString().equals(ZERO)
                    || sevInfo.get(COUNT).toString().equals(DOUBLE_ZERO)) {
                appTemp.put("days", 0);
            } else {
                appTemp.put("days", Math.floor(Double.valueOf(sevInfo.get(
                        "days").toString())
                        / Double.valueOf(sevInfo.get(COUNT).toString())));
            }

            appData.add(appTemp);
            if (!directorData.isEmpty()) {
                String director;
                if (StringUtils.isEmpty(directApp.get(appName)))
                    director = UNKNOWN;
                else
                    director = directApp.get(appName);

                boolean directorExists = false;
                for (Map<String, Object> existingDirectorData : directorData) {
                    if (director.equals(existingDirectorData.get("name"))) {
                        existingDirectorData.put(
                                "days",
                                Double.valueOf(existingDirectorData.get("days")
                                        .toString())
                                        + Double.valueOf(sevInfo.get("days")
                                                .toString()));
                        existingDirectorData.put(
                                COUNT,
                                Double.valueOf(existingDirectorData.get(COUNT)
                                        .toString())
                                        + Double.valueOf(sevInfo.get(COUNT)
                                                .toString()));
                        directorExists = true;
                        break;
                    }
                }
                if (!directorExists) {
                    Map<String, Object> directorTemp = new HashMap<>();
                    directorTemp.put("name", director);
                    directorTemp.put("days", sevInfo.get("days"));
                    directorTemp.put(COUNT, sevInfo.get(COUNT));
                    directorData.add(directorTemp);
                }
            } else {
                Map<String, Object> directorTemp = new HashMap<>();
                if (StringUtils.isEmpty(directApp.get(appName))) {
                    directorTemp.put("name", UNKNOWN);
                } else
                    directorTemp.put("name", directApp.get(appName));
                directorTemp.put("days", sevInfo.get("days"));
                directorTemp.put(COUNT, sevInfo.get(COUNT));
                directorData.add(directorTemp);
            }

            if (!vpData.isEmpty()) {
                String vp;
                if (StringUtils.isEmpty(vpApp.get(appName)))
                    vp = UNKNOWN;
                else
                    vp = vpApp.get(appName);

                boolean vpExists = false;
                for (Map<String, Object> existingVpData : vpData) {
                    if (vp.equals(existingVpData.get("name"))) {
                        existingVpData.put(
                                "days",
                                Double.valueOf(existingVpData.get("days")
                                        .toString())
                                        + Double.valueOf(sevInfo.get("days")
                                                .toString()));
                        existingVpData.put(
                                COUNT,
                                Double.valueOf(existingVpData.get(COUNT)
                                        .toString())
                                        + Double.valueOf(sevInfo.get(COUNT)
                                                .toString()));
                        vpExists = true;
                        break;
                    }
                }
                if (!vpExists) {
                    Map<String, Object> vpTemp = new HashMap<>();
                    vpTemp.put("name", vp);
                    vpTemp.put("days", sevInfo.get("days"));
                    vpTemp.put(COUNT, sevInfo.get(COUNT));
                    vpData.add(vpTemp);
                }
            } else {
                Map<String, Object> vpTemp = new HashMap<>();
                if (StringUtils.isEmpty(vpApp.get(appName))) {
                    vpTemp.put("name", UNKNOWN);
                } else
                    vpTemp.put("name", vpApp.get(appName));
                vpTemp.put("days", sevInfo.get("days"));
                vpTemp.put(COUNT, sevInfo.get(COUNT));
                vpData.add(vpTemp);
            }
        }

        directorData.parallelStream().forEach(
                director -> {
                    if (director.get(COUNT).toString().equals(ZERO)
                            || director.get(COUNT).toString()
                                    .equals(DOUBLE_ZERO)) {
                        director.put("days", 0);
                    } else {
                        director.put("days",
                                Math.floor(Double.valueOf(director.get("days")
                                        .toString())
                                        / Double.valueOf(director.get(COUNT)
                                                .toString())));
                    }
                    director.remove(COUNT);
                });
        vpData.parallelStream().forEach(
                vp -> {
                    if (vp.get(COUNT).toString().equals(ZERO)
                            || vp.get(COUNT).toString().equals(DOUBLE_ZERO)) {
                        vp.put("days", 0);
                    } else {
                        vp.put("days", Math.floor(Double.valueOf(vp.get("days")
                                .toString())
                                / Double.valueOf(vp.get(COUNT).toString())));
                    }
                    vp.remove(COUNT);
                });

        Map<String, Object> vpInfo = new LinkedHashMap<>();
        vpInfo.put("type", "VP");
        vpInfo.put("data", vpData);
        Map<String, Object> directorInfo = new LinkedHashMap<>();
        directorInfo.put("type", "Director");
        directorInfo.put("data", directorData);
        Map<String, Object> appInfo = new LinkedHashMap<>();
        appInfo.put("type", "Application");
        appInfo.put("data", appData);

        List<Map<String, Object>> distributionList = new ArrayList<>();
        distributionList.add(vpInfo);
        distributionList.add(directorInfo);
        distributionList.add(appInfo);

        Map<String, Object> severityMap = new HashMap<>();
        severityMap.put(SEVERITY, Integer.valueOf(severity));
        severityMap.put("distribution", distributionList);
        return severityMap;
    }

    /**
     * Gets the vulnerability by qid.
     *
     * @param qid the qid
     * @return the vulnerability by qid
     */
    public List<Map<String, Object>> getVulnerabilityByQid(String qid) {

        List<Map<String, Object>> vulnByCategories = new ArrayList<>();
        Map<String, Object> vulnKbData = vulnerabilityRepository
                .getVulnerabilityByQid(qid);
        vulnByCategories.add(formGeneralCategory(vulnKbData));
        vulnByCategories.add(formDetailsCategory(vulnKbData));
        vulnByCategories.add(formSoftwareCategory(vulnKbData));
        vulnByCategories.add(formImpactCategory(vulnKbData));
        vulnByCategories.add(formThreatCategory(vulnKbData));
        vulnByCategories.add(formSolutionCategory(vulnKbData));
        vulnByCategories.add(formExploitabilityCategory(vulnKbData));
        vulnByCategories.add(formAssociatedMalware(vulnKbData));
        return vulnByCategories;
    }

    /**
     * Form general category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> formGeneralCategory(
            Map<String, Object> vulnKbData) {

        ObjectMapper oMapper = new ObjectMapper();

        Map<String, Object> category = new LinkedHashMap<>();
        category.put("name", "General Information");
        Map<String, Object> attributes = new LinkedHashMap<>();
        attributes.put("QID",
                null == vulnKbData.get("qid") ? "" : vulnKbData.get("qid"));
        attributes.put("Title",
                null == vulnKbData.get(TITLE) ? "" : vulnKbData.get(TITLE));
        attributes.put(
                "Severity Level",
                null == vulnKbData.get(SEVEITY_LEVEL) ? "" : vulnKbData
                        .get(SEVEITY_LEVEL));
        attributes.put(
                "Vulnerability Type",
                null == vulnKbData.get(VULN_TYPE) ? "" : vulnKbData
                        .get(VULN_TYPE));
        attributes.put("Category", null == vulnKbData.get(CATEGORY) ? ""
                : vulnKbData.get(CATEGORY));

        Map<String, Object> discovery = oMapper.convertValue(
                vulnKbData.get("discovery"), Map.class);

        if (discovery != null) {
            attributes
                    .put("Authentication",
                            fetchAttributes(discovery, "authtypelist",
                                    "authtype", true));
        }

        attributes.put("Service Modified",
                null == vulnKbData.get("lastservicemodificationdatetime") ? ""
                        : vulnKbData.get("lastservicemodificationdatetime"));
        attributes.put(
                "Published",
                null == vulnKbData.get("publisheddatetime") ? "" : vulnKbData
                        .get("publisheddatetime"));

        category.put(ATTRIBUTES, attributes);
        return category;
    }

    /**
     * Form details category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> formDetailsCategory(
            Map<String, Object> vulnKbData) {
        ObjectMapper oMapper = new ObjectMapper();
        Map<String, Object> category = new HashMap<>();
        category.put("name", "Details");
        Map<String, Object> attributes = new LinkedHashMap<>();
        if (Arrays.asList(
                fetchAttributes(vulnKbData, "discovery", "additionalinfo",
                        false).toString().split("\\s*,\\s*")).contains(
                "Patch Available")) {
            attributes.put("Patch Availble", "Yes");
        } else
            attributes.put("Patch Availble", "No");

        attributes.put("CVE ID",
                fetchAttributes(vulnKbData, "cvelist", "cve", true));
        attributes.put(
                "Vendor Reference",
                fetchAttributes(vulnKbData, "vendorreferencelist",
                        "vendorreference", true));
        attributes.put("Bugtraq ID",
                fetchAttributes(vulnKbData, "bugtraqlist", "bugtraq", true));

        if (null != vulnKbData.get("pciflag")) {
            attributes.put("PCI Flag", Double.valueOf(vulnKbData.get("pciflag")
                    .toString()) == 0 ? false : true);
        }

        attributes.put("PCI Reasons",
                fetchAttributes(vulnKbData, "pcireasons", "pcireason", true));
        if (null != vulnKbData.get("supportedmodules")) {
            attributes.put("Supported Modules",
                    vulnKbData.get("supportedmodules"));
        }

        Map<String, Object> cvss = oMapper.convertValue(vulnKbData.get("cvss"),
                Map.class);
        Map<String, Object> cvss3 = oMapper.convertValue(
                vulnKbData.get("cvssv3"), Map.class);
        if (cvss != null) {
            attributes.put("CVSS Base", cvss.get("base"));
            attributes.put("CVSS Temporal", cvss.get("temporal"));
            attributes.put("CVSS Access Vector",
                    fetchAttributes(cvss, "access", "vector", false));
        }
        if (cvss3 != null) {
            attributes.put("CVSS3 Base", cvss3.get("base"));
            attributes.put("CVSS3 Temporal", cvss3.get("temporal"));
        }

        category.put(ATTRIBUTES, attributes);
        return category;
    }

    /**
     * Form software category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    private Map<String, Object> formSoftwareCategory(
            Map<String, Object> vulnKbData) {

        Map<String, Object> category = new HashMap<>();
        category.put("name", "Software");
        category.put(ATTRIBUTES,
                fetchAttributes(vulnKbData, "softwarelist", "software", true));
        return category;
    }

    /**
     * Form threat category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    private Map<String, Object> formThreatCategory(
            Map<String, Object> vulnKbData) {

        Map<String, Object> category = new HashMap<>();
        category.put("name", "Threat");
        category.put(ATTRIBUTES, null == vulnKbData.get("diagnosis") ? ""
                : vulnKbData.get("diagnosis"));
        return category;
    }

    /**
     * Form impact category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    private Map<String, Object> formImpactCategory(
            Map<String, Object> vulnKbData) {

        Map<String, Object> category = new HashMap<>();
        category.put("name", "Impact");
        category.put(ATTRIBUTES, null == vulnKbData.get("consequence") ? ""
                : vulnKbData.get("consequence"));
        return category;
    }

    /**
     * Form solution category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    private Map<String, Object> formSolutionCategory(
            Map<String, Object> vulnKbData) {

        Map<String, Object> category = new HashMap<>();
        category.put("name", "Solution");
        category.put(ATTRIBUTES, null == vulnKbData.get("solution") ? ""
                : vulnKbData.get("solution"));
        return category;
    }

    /**
     * Form exploitability category.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> formExploitabilityCategory(
            Map<String, Object> vulnKbData) {

        ObjectMapper oMapper = new ObjectMapper();
        List<Map<String, Object>> attributes = new ArrayList<>();
        Map<String, Object> category = new HashMap<>();
        category.put("name", "Exploitability");

        Map<String, Object> correlation = oMapper.convertValue(
                vulnKbData.get("correlation"), Map.class);
        if (correlation != null && !correlation.isEmpty()) {
            List<Map<String, Object>> exploits = (List<Map<String, Object>>) fetchAttributes(
                    correlation, "exploits", "expltsrc", true);
            for (Map<String, Object> exploitTemp : exploits) {
                Map<String, Object> exploit = new HashMap<>();
                exploit.put(SRC_NAME, exploitTemp.get(SRC_NAME));
                exploit.put(
                        "exploits",
                        fetchAttributes(exploitTemp, "expltlist", "explt", true));
                attributes.add(exploit);
            }
        }
        category.put(ATTRIBUTES, attributes);
        return category;
    }

    /**
     * Form associated malware.
     *
     * @param vulnKbData the vuln kb data
     * @return the map
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> formAssociatedMalware(
            Map<String, Object> vulnKbData) {
        ObjectMapper oMapper = new ObjectMapper();
        List<Map<String, Object>> attributes = new ArrayList<>();
        Map<String, Object> category = new HashMap<>();
        category.put("name", "Malware");

        Map<String, Object> correlation = oMapper.convertValue(
                vulnKbData.get("correlation"), Map.class);
        if (correlation != null && !correlation.isEmpty()) {
            List<Map<String, Object>> exploits = (List<Map<String, Object>>) fetchAttributes(
                    correlation, "malware", "mwsrc", true);
            for (Map<String, Object> exploitTemp : exploits) {
                Map<String, Object> exploit = new HashMap<>();
                exploit.put(SRC_NAME, exploitTemp.get(SRC_NAME));
                exploit.put("malwares",
                        fetchAttributes(exploitTemp, "mwlist", "mwinfo", true)); 
                attributes.add(exploit);
            }
        }
        category.put(ATTRIBUTES, attributes);
        return category;
    }

    /**
     * Fetch attributes.
     *
     * @param vulnKbData the vuln kb data
     * @param parent the parent
     * @param child the child
     * @param isList the is list
     * @return the object
     */
    @SuppressWarnings("unchecked")
    private Object fetchAttributes(Map<String, Object> vulnKbData,
            String parent, String child, boolean isList) {
        Map<String, Object> parentMap = new ObjectMapper().convertValue(
                vulnKbData.get(parent), Map.class);
        Object childObj;
        if (parentMap != null) {
            childObj = parentMap.get(child);
            if (childObj != null)
                return childObj;
        }

        if (isList) {
            return new ArrayList<>();
        } else {
            return "";
        }
    }
    
    /**
     * Gets the distribution summary.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the distribution summary
     */
    @SuppressWarnings("unchecked")
    private Map<String, Map<String, Object>> getDistributionSummary(String assetGroup, String severity) {
        
        List<Map<String, Object>> vulnApplications = new ArrayList<>();
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
        if (!vulnTargetTypes.isEmpty()) {
            for (String parentType : vulnTargetTypes) {
                try {
                    vulnApplications.addAll(vulnerabilityRepository
                            .getVulnerabilyAcrossAppAndEnv(assetGroup,
                                    "tags.Application.keyword", "", parentType,
                                    severity));
                } catch (Exception e) {
                    logger.error("Exception in getting getDistributionSummary ",e);
                }
            }
        }
        
        Map<String, Map<String, Object>> appDetails = new ConcurrentHashMap<>();
        vulnApplications
                .parallelStream()
                .forEach(
                        vulnApps -> {
                            List<Map<String, Object>> severityInfo = (List<Map<String, Object>>) vulnApps
                                    .get(SEV_INFO);
                            Map<String, Object> sevDetails = new HashMap<>();
                            severityInfo.forEach(sevInfo -> {
                                sevDetails.put(
                                        sevInfo.get(SEVERITY).toString(),
                                        sevInfo.get(COUNT));
                            });
                            appDetails.put(vulnApps.get("application")
                                    .toString(), sevDetails);
                        });
        return appDetails;
    }
    
    /**
     * Form director and VP by app.
     *
     * @param directApp the direct app
     * @param vpApp the vp app
     */
    private void formDirectorAndVPByApp(Map<String, String> directApp, Map<String, String> vpApp) {
        try {
            vulnerabilityRepository
                    .fetchExecDirectorApps()
                    .parallelStream()
                    .forEach(
                            app -> {
                                if(null != directApp) {
                                    directApp.put(app.get(APP_TAG).toString(), app
                                        .get("director").toString());
                                }
                                if(null != vpApp) {
                                    vpApp.put(app.get(APP_TAG).toString(),
                                        app.get("executiveSponsor").toString());
                                }
                            });

        } catch (Exception e) {
            logger.error(e);
        }
    }
    
    /**
     * Gets the highest lowest performers.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @param type the type
     * @return the highest lowest performers
     */
    @SuppressWarnings("unchecked")
    public Map<String, Integer> getHighestLowestPerformers(String assetGroup, String severity,String type) {
        
        Map<String, Long> appDetails = new HashMap<>();
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
        
        if(StringUtils.isBlank(severity)) {
            severity=SEVERITY_LEVELS;
        }
        Map<String,Integer> perfData = new HashMap<>();
        
        if("org".equalsIgnoreCase(type)){
            if (!vulnTargetTypes.isEmpty()) {
                for (String parentType : vulnTargetTypes) {
                    try {
                        Map<String, Long> appDetailsTemp = vulnerabilityRepository.getAppsBySeverity(assetGroup, parentType, severity);
                        if(appDetails.isEmpty()) {
                            appDetails = new HashMap<>(appDetailsTemp);
                        } else {
                            for(Entry<String, Long> appDetailTemp : appDetailsTemp.entrySet()) {
                                boolean appExists = false;
                                for(Entry<String, Long> appDetail : appDetails.entrySet()) {
                                    if(appDetail.getKey().equals(appDetailTemp.getKey())){
                                        appDetails.put(appDetail.getKey(),appDetail.getValue()+appDetailTemp.getValue());
                                        appExists = true;
                                        break;
                                    }
                                }
                                if(!appExists) {
                                    appDetails.put(appDetailTemp.getKey(),appDetailTemp.getValue());
                                }
                            }
                        }
                    } catch (Exception e) {
                        logger.error("Exception in getHighestLowestPeformers ",e);
                    }
                }
            }
            
            Map<String, String> directApp = new ConcurrentHashMap<>();
            formDirectorAndVPByApp(directApp, null);
             
           
            for (Entry<String, Long> entry : appDetails.entrySet()) {
                
                String appName = entry.getKey();
                
                if (!perfData.isEmpty()) {
                    String director;
                    if (StringUtils.isEmpty(directApp.get(appName)))
                        director = UNKNOWN;
                    else
                        director = directApp.get(appName).trim();
                    
                    boolean directorExists = false;
                    for (Entry<String, Integer> existingDirectorData : perfData.entrySet()) {
                        if (director.equals(existingDirectorData.getKey())) {
                            perfData.put(
                                    director,existingDirectorData.getValue()+ Integer.valueOf(entry.getValue().toString()));
                            directorExists = true;
                            break;
                        }
                    }
                    if (!directorExists) {
                        perfData.put(director, Integer.valueOf(entry.getValue().toString()));
                    }
                } else {
                    if(StringUtils.isEmpty(directApp.get(appName))) {
                        perfData.put(UNKNOWN, Integer.valueOf(entry.getValue().toString()));
                    } else 
                        perfData.put(directApp.get(appName),Integer.valueOf(entry.getValue().toString()));
                }
            }
            
        }else if(APPLICATION.equalsIgnoreCase(type)){
            try{
                List<Map<String, Object>> vulnApplications = getVulnerabilityByAppAndEnv(
                    assetGroup, TAGS_APPS, "");
                for(Map<String, Object> appInfo:vulnApplications) {
                    String app = appInfo.get(APPS).toString();
                    List<Map<String,Object>> sevInfo =  (List<Map<String,Object>>)appInfo.get(SEV_INFO);
                    perfData.put(app, getVulnInstanceCount(sevInfo,severity));
                }
            }catch(Exception e){
                
            }
           
        }else if(ENVIRONMENT.equalsIgnoreCase(type)){
            
            try{
                List<Map<String, Object>> vulnEnvmnts = getVulnerabilityByAppAndEnv(
                        assetGroup, TAGS_ENV, "");
                for(Map<String, Object> envInfo:vulnEnvmnts) {
                    String env = envInfo.get(ENV).toString();
                    List<Map<String,Object>> sevInfo =  (List<Map<String,Object>>)envInfo.get(SEV_INFO);
                    perfData.put(env, getVulnInstanceCount(sevInfo,severity));
                }
            }catch(Exception e){
                
            }
        }
        
        return perfData.entrySet().stream()
                .sorted(Map.Entry.comparingByValue())
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
                        (oldValue, newValue) -> oldValue, LinkedHashMap::new));
    }
    
    /**
     * Gets the vuln instance count.
     *
     * @param sevInfoList the sev info list
     * @param severity the severity
     * @return the vuln instance count
     */
    private int getVulnInstanceCount(List<Map<String,Object>> sevInfoList, String severity){
        List<String> sevList = Arrays.asList(severity.split(","));
        return sevInfoList.stream().filter(sevInfo-> sevList.contains(sevInfo.get("severitylevel").toString())).mapToInt(sevInfo-> Double.valueOf(sevInfo.get("vulnInstanceCount").toString()).intValue()).sum();
    }
    
    /**
     * Gets the vuln target types.
     *
     * @param assetGroup the asset group
     * @return the vuln target types
     */
    private  List<String> getVulnTargetTypes(String assetGroup) {
        
        String validTargetTypes = getTargetTypes(assetGroup);
        List<String> vulnTargetTypes = new ArrayList<>();
        for (String vulnType : vulnTypes.split(",")) {
            if (!StringUtils.isEmpty(validTargetTypes)
                    && validTargetTypes.contains(vulnType.trim())) {
                vulnTargetTypes.add(vulnType);
            }
        }
        return vulnTargetTypes;
    }
    
    /**
     * Gets the distribution summary by infra type.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the distribution summary by infra type
     * @throws ServiceException the service exception
     */
    public List<Map<String, Object>> getDistributionSummaryByInfraType(String assetGroup, String severity) throws ServiceException {
        
        List<Map<String,Object>> distributionList = new ArrayList<>();
        
        List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
        if(StringUtils.isBlank(severity)) {
            severity=SEVERITY_LEVELS;
        }
        long totalVulnCount = 0;
        for (String vulnType : vulnTargetTypes) {
            Map<String,Object> info = new HashMap<>();
            try{
                info = vulnerabilityRepository.
                        getDistributionSummaryByInfraType(assetGroup, severity, vulnType);
           }catch(Exception e){
               logger.error("Error in getDistributionSummaryByInfraType ", e);
               throw new ServiceException();
           }
            
           totalVulnCount += Long.valueOf(info.get(VULNEREBILITIES).toString());
           
           if(vulnType.equals(EC2)) {
               info.put(CATEGORY, "Cloud");
           } else {
               info.put(CATEGORY, "On-Prem");
           }
           distributionList.add(info);
        }
        
        double contribution = HUNDRED;
        for(int i=0;i<distributionList.size();i++) {
            Map<String,Object> info = distributionList.get(i);
            double contributionPercent = Math.floor((Double.valueOf(info.get(VULNEREBILITIES).toString())/totalVulnCount)*HUNDRED);
            if(i== distributionList.size()-1){
                info.put(CONTRIBUTION, contribution);
            }else{
                info.put(CONTRIBUTION, contributionPercent);
                contribution = contribution-contributionPercent;
            }
        }
        return distributionList;
    }
    
    /**
     * Gets the distribution summary by env.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the distribution summary by env
     * @throws ServiceException the service exception
     */
    public List<Map<String, Object>> getDistributionSummaryByEnv(String assetGroup, String severity) throws ServiceException {
        
        List<Map<String,Object>> distributionList = new ArrayList<>();
        if(StringUtils.isBlank(severity)) {
            severity=SEVERITY_LEVELS;
        }
        
        long totalVulnCount = 0;
        
        Map<String,Object> prodInfo = new HashMap<>();
        prodInfo.put(TOTAL_VULN_ASSETS, 0);
        prodInfo.put(VULNEREBILITIES, 0);
        prodInfo.put(UNIQUE_VULN_COUNT, 0);
        
        Map<String,Object> nonProdInfo = new HashMap<>();
        nonProdInfo.put(TOTAL_VULN_ASSETS, 0);
        nonProdInfo.put(VULNEREBILITIES, 0);
        nonProdInfo.put(UNIQUE_VULN_COUNT, 0);
        try {
            Map<String, Long> prodInfoTemp = vulnerabilityRepository.getProdInfoByEnv(assetGroup, severity);
            Map<String, Long> nonProdInfoTemp = vulnerabilityRepository.getNonProdInfoByEnv(assetGroup, severity);
            
            totalVulnCount += prodInfoTemp.get(VULNEREBILITIES)+nonProdInfoTemp.get(VULNEREBILITIES);
            
            for (Entry<String, Object> entry : prodInfo.entrySet()) {
                prodInfo.put(entry.getKey(), Long.valueOf(entry.getValue().toString())+prodInfoTemp.get(entry.getKey()));
            }
            
            for (Entry<String, Object> entry : nonProdInfo.entrySet()) {
                nonProdInfo.put(entry.getKey(), Long.valueOf(entry.getValue().toString())+nonProdInfoTemp.get(entry.getKey()));
            }
        } catch (Exception e) {
            throw new ServiceException(e);
        }
        prodInfo.put(CATEGORY,"Prod");
        distributionList.add(prodInfo);
        nonProdInfo.put(CATEGORY,"Non-Prod");
        distributionList.add(nonProdInfo);
        
        double contribution = HUNDRED;
        for(int i=0;i<distributionList.size();i++) {
            Map<String,Object> info = distributionList.get(i);
            if(totalVulnCount > 0) {
                double contributionPercent = Math.floor((Double.valueOf(info.get(VULNEREBILITIES).toString())/totalVulnCount)*HUNDRED);
                if(i== distributionList.size()-1){
                    info.put(CONTRIBUTION, contribution);
                }else{
                    info.put(CONTRIBUTION, contributionPercent);
                    contribution = contribution-contributionPercent;
                }
            } else {
                info.put(CONTRIBUTION, 0);
            }
        }
        return distributionList;
    }
    
    /**
     * Gets the distribution summary by vuln type.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the distribution summary by vuln type
     * @throws DataException the data exception
     */
    public List<Map<String, Object>> getDistributionSummaryByVulnType(String assetGroup, String severity) throws DataException {
        if(StringUtils.isBlank(severity)) {
            severity=SEVERITY_LEVELS;
        }
        return vulnerabilityRepository.getDistributionSummaryByVulnType(assetGroup, severity);
    }
    
    /**
     * Gets the remediation actions summary.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the remediation actions summary
     * @throws DataException the data exception
     */
    public List<Map<String, Object>> getRemediationActionsSummary(String assetGroup, String severity) throws DataException {
        
        List<Map<String,Object>> remediationList = new ArrayList<>();
        if(StringUtils.isBlank(severity)) {
            severity=SEVERITY_LEVELS;
        }
        
        List<Map<String,Object>> eolActions = vulnerabilityRepository.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
                + "action='Remove/Replace EOL Software'");
        List<Map<String,Object>> stopRemoveActions = vulnerabilityRepository.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
                + "action='Stop Service/Remove Software'");
        List<Map<String,Object>> swConfigChangeActions = vulnerabilityRepository.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
                + "action='Software Configuration Change'");
        List<Map<String,Object>> swUpdateActions = vulnerabilityRepository.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
                + "action='Software Update'");
        
        String softwareConfig = getAllMatchingString(swConfigChangeActions);
        String softwareUpdate = getAllMatchingString(swUpdateActions);
        
        Map<String,Object> osPatching = new HashMap<>();
        osPatching.put(ACTION, "OS Patching");
        osPatching.put(DESCRIPTION, "Apply the patches released by the operating system provider");
        osPatching.put(CONTRIBUTION, 0);
        Map<String,Object> eolSoftware = new HashMap<>();
        eolSoftware.put(ACTION, "Remove/Replace EOL Software");
        eolSoftware.put(CONTRIBUTION, 0);
        eolSoftware.put(DESCRIPTION, "Remove or replace below listed End of Life Software versions");
        Map<String,Object> noSolution = new HashMap<>();
        noSolution.put(ACTION, "No Solution Available");
        noSolution.put(CONTRIBUTION, 0);
        noSolution.put(DESCRIPTION, "Vulnerabilities with no published solution yet");
        Map<String,Object> stopRemove = new HashMap<>();
        stopRemove.put(ACTION, "Stop Service/Remove Software");
        stopRemove.put(CONTRIBUTION, 0);
        stopRemove.put(DESCRIPTION, "Stop unimportant vulnerable services, remove malicious softwares from the hosts");
        Map<String,Object> swConfigChange = new HashMap<>();
        swConfigChange.put(ACTION, "Software Configuration Change");
        swConfigChange.put(CONTRIBUTION, 0);
        swConfigChange.put(DESCRIPTION, "Fix the configurations of the below listed softwares. Some default configurations like default admin username and password should be replaced with a stronger one");
        Map<String,Object> swUpdate = new HashMap<>();
        swUpdate.put(ACTION, "Software Update");
        swUpdate.put(CONTRIBUTION, 0);
        swUpdate.put(DESCRIPTION, "Update the below listed softwares to their latest version or apply patches released by the software provider ");
        
        List<Map<String,Object>> eolSubActions = new ArrayList<>();
        List<Map<String,Object>> stopRemoveSubActions = new ArrayList<>();
        List<Map<String,Object>> swConfigChangeSubActions = new ArrayList<>();
        List<Map<String,Object>> swUpdateSubActions = new ArrayList<>();
        
        Map<String,Object> unclassified = new HashMap<>();
        unclassified.put(ACTION, "Unclassified");
        unclassified.put(DESCRIPTION, "These vulnerabilities are not classified yet. Refer the vulnerability description to fix the vulnerability");
        unclassified.put(CONTRIBUTION, 0);
        
        Map<String, Object> qids = vulnerabilityRepository.getAllQidByAG(assetGroup, severity);
        Long total = qids.entrySet().stream().mapToLong(entry-> Long.valueOf(entry.getValue().toString())).sum();
        for (String qidTitleClass: qids.keySet()) {
            String qid = qidTitleClass.split("~")[0];
            String vulnTitle = qidTitleClass.split("~")[1].toLowerCase();
            String classification = qidTitleClass.split("~")[2];
            if("OS".equalsIgnoreCase(classification)){
                osPatching.put(CONTRIBUTION, Long.valueOf(osPatching.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
            }else if(vulnTitle.contains("EOL/Obsolete".toLowerCase())) {
                eolSoftware.put(CONTRIBUTION, Long.valueOf(eolSoftware.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
                formSubActionList(eolActions,eolSubActions,vulnTitle,Long.valueOf(qids.get(qidTitleClass).toString()));
            } else if("11925".equals(qid) || "370914".equals(qid)) {
                noSolution.put(CONTRIBUTION, Long.valueOf(noSolution.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
            } else if(vulnTitle.contains("Java Debug Wire Protocol".toLowerCase())) {
                stopRemove.put(CONTRIBUTION, Long.valueOf(stopRemove.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
                formSubActionList(stopRemoveActions,stopRemoveSubActions,vulnTitle,Long.valueOf(qids.get(qidTitleClass).toString()));
            } else if(checkVulnTitle(vulnTitle,softwareConfig)) {
                swConfigChange.put(CONTRIBUTION, Long.valueOf(swConfigChange.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
                formSubActionList(swConfigChangeActions,swConfigChangeSubActions,vulnTitle,Long.valueOf(qids.get(qidTitleClass).toString()));
            } else if(checkVulnTitle(vulnTitle,softwareUpdate)) {
                swUpdate.put(CONTRIBUTION, Long.valueOf(swUpdate.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
                formSubActionList(swUpdateActions,swUpdateSubActions,vulnTitle,Long.valueOf(qids.get(qidTitleClass).toString()));
            } else {
                unclassified.put(CONTRIBUTION, Long.valueOf(unclassified.get(CONTRIBUTION).toString())+Long.valueOf(qids.get(qidTitleClass).toString()));
            }
        }
        
        calculateContributionPercentage(eolSubActions,Long.valueOf(eolSoftware.get(CONTRIBUTION).toString()));
        calculateContributionPercentage(stopRemoveSubActions,Long.valueOf(stopRemove.get(CONTRIBUTION).toString()));
        calculateContributionPercentage(swConfigChangeSubActions,Long.valueOf(swConfigChange.get(CONTRIBUTION).toString()));
        calculateContributionPercentage(swUpdateSubActions,Long.valueOf(swUpdate.get(CONTRIBUTION).toString()));
        
        eolSoftware.put(SUB_ACTIONS, eolSubActions);
        stopRemove.put(SUB_ACTIONS, stopRemoveSubActions);
        swConfigChange.put(SUB_ACTIONS, swConfigChangeSubActions);
        swUpdate.put(SUB_ACTIONS, swUpdateSubActions);
        
        remediationList.add(osPatching);
        remediationList.add(eolSoftware);
        remediationList.add(noSolution);
        remediationList.add(stopRemove);
        remediationList.add(swConfigChange);
        remediationList.add(swUpdate);
        remediationList.add(unclassified);
        
        calculateContributionPercentage(remediationList,total);
        return remediationList;
    }
    
    /**
     * Check vuln title.
     *
     * @param vulnTitle the vuln title
     * @param values the values
     * @return true, if successful
     */
    private boolean checkVulnTitle(String vulnTitle, String values) {
        for(String value : values.split(",")) {
            if(vulnTitle.contains(value)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Form sub action list.
     *
     * @param actions the actions
     * @param subActions the sub actions
     * @param vulnTitle the vuln title
     * @param contribution the contribution
     */
    private void formSubActionList(List<Map<String,Object>> actions, List<Map<String,Object>> subActions,String vulnTitle, long contribution) {
        boolean titleMatched = false;
        for(Map<String,Object> action : actions) {
            if(vulnTitle.contains(action.get(MATCHING_STRING).toString().toLowerCase())) {
                titleMatched = true;
                formSubAction(subActions, action.get("subAction").toString(), action.get(MATCHING_STRING).toString(), contribution);
                break;
            }
        }
        if(!titleMatched) {
            formSubAction(subActions, "Others", "Others", contribution);
        }
    }
    
    /**
     * Form sub action.
     *
     * @param subActions the sub actions
     * @param subActionTitle the sub action title
     * @param subActiondescr the sub actiondescr
     * @param contribution the contribution
     */
    private void formSubAction(List<Map<String,Object>> subActions, String subActionTitle, String subActiondescr, Long contribution) {
        if(subActions.isEmpty()) {
            Map<String,Object> subAction = new HashMap<>();
            subAction.put(ACTION, subActionTitle);
            subAction.put(DESCRIPTION, subActiondescr);
            subAction.put(CONTRIBUTION, contribution);
            subActions.add(subAction);
        } else {
            boolean subActionExists = false;
            for(Map<String,Object> subAction : subActions) {
                if(subActionTitle.equals(subAction.get(ACTION).toString())) {
                    subActionExists = true;
                    subAction.put(CONTRIBUTION, Long.valueOf(subAction.get(CONTRIBUTION).toString())+contribution);
                    break;
                }
            }
            if(!subActionExists) {
                Map<String,Object> subAction = new HashMap<>();
                subAction.put(ACTION, subActionTitle);
                subAction.put(DESCRIPTION, subActiondescr);
                subAction.put(CONTRIBUTION, contribution);
                subActions.add(subAction);
            }
        }
    }
    
    /**
     * Gets the all matching string.
     *
     * @param actions the actions
     * @return the all matching string
     */
    private String getAllMatchingString(List<Map<String,Object>> actions) {
        List<String> matchingStrings = new ArrayList<>();
        for(Map<String,Object> action : actions) {
            matchingStrings.add(action.get(MATCHING_STRING).toString().toLowerCase());
        }
        return StringUtils.join(matchingStrings, ",");
    }
    
    /**
     * Calculate contribution percentage.
     *
     * @param contributionList the contribution list
     * @param total the total
     */
    private void calculateContributionPercentage(List<Map<String,Object>> contributionList, long total) {
        DecimalFormat df = new DecimalFormat("###.##");
        ListIterator<Map<String, Object>> it = contributionList.listIterator();
        String contributionPercent;
        while(it.hasNext()){
            Map<String,Object> bucket = it.next();
            Long contribution = Long.valueOf(bucket.get(CONTRIBUTION).toString());
            if(contribution==0){
                it.remove();
            }else{
                contributionPercent =  df.format((contribution*HUNDRED)/total);
                if("0".equals(contributionPercent)){
                    it.remove(); 
                }else{
                    bucket.put(CONTRIBUTION, Float.valueOf(contributionPercent));
                }
            }
        }
    }
    
    /**
     * Creates the trend annotation.
     *
     * @param request the request
     * @return true, if successful
     * @throws JsonProcessingException the json processing exception
     */
    public boolean createTrendAnnotation(TrendNote request) throws JsonProcessingException {
        return vulnerabilityRepository.createTrendAnnotation(request);
    }
    
    /**
     * Gets the trend annotations.
     *
     * @param assetGroup the asset group
     * @param from the from
     * @return the trend annotations
     * @throws DataException the data exception
     */
    public List<Map<String,Object>> getTrendAnnotations(String assetGroup, Date from) throws DataException {
        
        List<Map<String,Object>> globalAnnotations = new ArrayList<>();
        List<Map<String,Object>> assetGroupAnnotations = new ArrayList<>();
        List<Map<String,Object>> annotations = vulnerabilityRepository.getTrendAnnotations(assetGroup,from);
        
        annotations.parallelStream().forEach(annotation -> {
            if(StringUtils.isEmpty(annotation.get("ag").toString())) {
                synchronized (globalAnnotations) {
                    globalAnnotations.add(annotation);
                }
            } else {
                synchronized (assetGroupAnnotations) {
                    assetGroupAnnotations.add(annotation);
                }
            }
        });
        
        Map<String, Object> gloablMap = new HashMap<>();
        gloablMap.put("type", "Global");
        gloablMap.put("data", globalAnnotations);
        
        Map<String, Object> agMap = new HashMap<>();
        agMap.put("type", "AssetGroup");
        agMap.put("data", assetGroupAnnotations);
        
        List<Map<String,Object>> noteList = new ArrayList<>();
        noteList.add(agMap);
        noteList.add(gloablMap);
        
        return noteList;
    }
    
    /**
     * Delete trend annotation.
     *
     * @param noteId the note id
     * @return true, if successful
     */
    public boolean deleteTrendAnnotation(String noteId) {
        return vulnerabilityRepository.deleteTrendAnnotation(noteId);
    }
}
