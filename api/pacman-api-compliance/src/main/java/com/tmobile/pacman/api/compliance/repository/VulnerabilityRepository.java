/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.pacman.api.compliance.repository;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.PostConstruct;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.entity.ContentType;
import org.apache.http.nio.entity.NStringEntity;
import org.apache.http.util.EntityUtils;
import org.elasticsearch.client.Response;
import org.elasticsearch.client.RestClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.repo.ElasticSearchRepository;
import com.tmobile.pacman.api.commons.repo.PacmanRdsRepository;
import com.tmobile.pacman.api.commons.utils.CommonUtils;
import com.tmobile.pacman.api.commons.utils.PacHttpUtils;
import com.tmobile.pacman.api.compliance.domain.TrendNote;

/**
 * This is the Repository layer which makes call to ElasticSearch.
 */
@Repository
public class VulnerabilityRepository implements Constants {

	@Value("${elastic-search.host}")
	private String esHost;
	@Value("${elastic-search.port}")
	private int esPort;
	@Value("${elastic-search.update-host}")
    private String updateESHost;
    @Value("${elastic-search.update-port}")
    private int updateESPort;
	
	private static final String PROTOCOL = "http";
	
	private String esUrl;
	
	@Autowired
	private ElasticSearchRepository elasticSearchRepository;
	
	@Autowired
    private PacmanRdsRepository rdsRepository;
	
	private static final Log LOGGER = LogFactory.getLog(VulnerabilityRepository.class);
	
	private RestClient restClient;

	/**
	 * Initializes the esUrl.
	 */
	@PostConstruct
	void init() {
		esUrl = PROTOCOL + "://" + esHost + ":" + esPort;
	}

	/**
	 * Gets the all vulnerabilities.
	 *
	 * @param vulnAssetsAffectedQids the vuln assets affected qids
	 * @return the all vulnerabilities
	 * @throws DataException the DataException
	 */
	public List<Map<String, Object>> getAllVulnerabilities(
			List<String> vulnAssetsAffectedQids) throws DataException {

		List<Map<String, Object>> results = new ArrayList<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl)
				.append("/qualys-kb/kb/_search");
		String responseJson = "";
		try {
			for (int index = 0; index <= (vulnAssetsAffectedQids.size() / THOUSAND_TWENTY_FOUR); index++) {
				int from = index * THOUSAND_TWENTY_FOUR;
				int to = from + THOUSAND_TWENTY_FOUR;
				if (vulnAssetsAffectedQids.size() < to) {
					to = vulnAssetsAffectedQids.size();
				}
				StringBuilder requestBody = new StringBuilder(
						"{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"qid\":");
				requestBody.append(vulnAssetsAffectedQids.subList(from, to));
				requestBody.append("}}");
				requestBody.append("]}}}");
				responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
						requestBody.toString());
				elasticSearchRepository.processResponseAndSendTheScrollBack(
						responseJson, results);
			}
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityData", e);
			throw new DataException();
		}
		return results;
	}

	/**
	 * Gets the assets affected count.
	 *
	 * @param assetGroup the asset group
	 * @param filter the filter
	 * @param parentType the parent type
	 * @return the assets affected count
	 */
	public Map<String, Long> getAssetsAffectedCount(String assetGroup,
			Map<String, String> filter, String parentType) {

		Map<String, Long> assetsAffectedCount = new HashMap<>();
		Map<String, String> filterForQuery = new HashMap<>();
		if (!CollectionUtils.isEmpty(filter)) {
			filterForQuery = new HashMap<>(filter);
		}

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		String responseJson = "";
		try {
			String severity = SEVERITY_LEVELS;
			if (filterForQuery.containsKey(SEVEITY_LEVEL)) {
				severity = filterForQuery.get(SEVEITY_LEVEL);
				filterForQuery.remove(SEVEITY_LEVEL);
			}

			StringBuilder requestBody = new StringBuilder(
					"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel\":[");
			requestBody.append(severity + "]}},");
			requestBody
					.append("{\"has_parent\":{\"parent_type\":\""
							+ parentType
							+ "\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}");

			if (!filterForQuery.isEmpty()) {
				requestBody.append(",{\"match\":");
				requestBody.append(new GsonBuilder().create().toJson(
						filterForQuery));
				requestBody.append("}");
			}
			requestBody
					.append("]}}}}]}},\"aggs\":{\"qid\":{\"terms\":{\"field\":\"qid\",\"size\":");
			requestBody.append(ES_PAGE_SIZE);
			requestBody.append("}}}}");
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAssetsAffectedCount from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
					AGGREGATIONS).toString());
			JsonArray outerBuckets = aggsJson.getAsJsonObject("qid")
					.getAsJsonArray(BUCKETS);
			if (outerBuckets.size() > 0) {
				for (int i = 0; i < outerBuckets.size(); i++) {
					assetsAffectedCount.put(
							String.valueOf(outerBuckets.get(i)
									.getAsJsonObject().get("key").getAsLong()),
							outerBuckets.get(i).getAsJsonObject()
									.get(DOC_COUNT).getAsLong());
				}
			}
		}
		return assetsAffectedCount;
	}
	
	/**
	 * Gets the vulnerabily across app and env.
	 *
	 * @param assetGroup the asset group
	 * @param filter the filter
	 * @param application the application
	 * @param parentType the parent type
	 * @param severity the severity
	 * @return the vulnerabily across app and env
	 * @throws Exception the exception
	 */
	public List<Map<String, Object>> getVulnerabilyAcrossAppAndEnv(
			String assetGroup, String filter, String application,
			String parentType, String severity) throws Exception {

		List<Map<String, Object>> vulnApplications = new ArrayList<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(parentType);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}");
		if (StringUtils.isNotEmpty(application)) {
			requestBody.append(",{\"match\":{\"tags.Application.keyword\":\"");
			requestBody.append(application);
			requestBody.append("\"}}");
		}
		requestBody.append("]}},\"aggs\":{\"apps\":{\"terms\":{\"field\":\"");
		requestBody.append(filter);
		requestBody
				.append("\",\"size\":10000},\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"");
		if (StringUtils.isNotEmpty(severity)) {
			requestBody.append("S").append(severity);
			requestBody.append("\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"term\":{\"severitylevel\":")
					.append(severity).append("}}]}}");
		} else {
			requestBody
					.append("S3\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":3}},{\"match\":{\"latest\":true}}]}},\"S4\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":4}},{\"match\":{\"latest\":true}}]}},\"S5\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":5}},{\"match\":{\"latest\":true}}]}}");
		}
		requestBody.append("}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilyAcrossAppAndEnv from ES", e);
			throw e;
		}
		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
				AGGREGATIONS).toString());
		JsonArray outerBuckets = aggsJson.getAsJsonObject("apps")
				.getAsJsonArray(BUCKETS);
		if (outerBuckets.size() > 0) {
			for (int i = 0; i < outerBuckets.size(); i++) {
				String appName = outerBuckets.get(i).getAsJsonObject()
						.get("key").getAsString();
				List<Map<String, Object>> severityInfo = getSeverityInfo(
						outerBuckets.get(i).getAsJsonObject()
								.getAsJsonObject(VULN)
								.getAsJsonObject("NAME")
								.getAsJsonObject(BUCKETS), severity);
				Map<String, Object> applicationInfo = new HashMap<>();
				if (filter.equals(TAGS_APPS)) {
					applicationInfo.put(APPS, appName);
				} else {
					applicationInfo.put("environment", appName);
				}
				applicationInfo.put("severityinfo", severityInfo);
				if (StringUtils.isEmpty(severity)) {
					applicationInfo.put(
							VULNEREBILITIES,
							Integer.valueOf(severityInfo.get(0).get(COUNT)
									.toString())
									+ Integer.valueOf(severityInfo.get(1)
											.get(COUNT).toString())
									+ Integer.valueOf(severityInfo.get(2)
											.get(COUNT).toString()));
				} else {
					applicationInfo.put(
							VULNEREBILITIES,
							Integer.valueOf(severityInfo.get(0).get(COUNT)
									.toString()));
				}
				vulnApplications.add(applicationInfo);
			}
		}
		return vulnApplications;
	}

	/**
	 * Gets the vulnerability trend.
	 *
	 * @param assetGroup the asset group
	 * @param filter the filter
	 * @param from the from
	 * @param to the to
	 * @return the vulnerability trend
	 * @throws Exception the exception
	 */
	public List<Map<String, Object>> getVulnerabilityTrend(String assetGroup,
			Map<String, String> filter, Date from, Date to) throws Exception {
		List<Map<String, Object>> vulnTrendList = new ArrayList<>();
		try {

			StringBuilder urlToQuery = new StringBuilder(esUrl)
					.append("/assetgroup_stats/count_vuln/_search");
			StringBuilder request = new StringBuilder(
					"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"ag.keyword\":"
							+ "\"" + assetGroup + "\"}}");

			if (filter != null) {
				Set<String> filterkeys = filter.keySet();
				if (filterkeys.contains(TAGS_APPS)) {
					request.append(",{ \"match\": {\"tags.Application.keyword\": "
							+ "\""
							+ filter.get(TAGS_APPS)
							+ "\"}}");
				}
				if (filterkeys.contains("tags.Environment.keyword")) {
					request.append(",{ \"match\": {\"tags.Environment.keyword\": "
							+ "\""
							+ filter.get("tags.Environment.keyword")
							+ "\"}}");
				}
			}
			String gte = null;
			String lte = null;

			if (from != null) {
				gte = "\"gte\": \""
						+ new SimpleDateFormat("yyyy-MM-dd").format(from)
						+ "\"";
			}
			if (to != null) {
				lte = "\"lte\": \""
						+ new SimpleDateFormat("yyyy-MM-dd").format(to) + "\"";
			}

			if (gte != null && lte != null) {
				request.append(",{ \"range\": {\"date\": {" + gte + "," + lte
						+ "}}}");
			} else if (gte != null) {
				request.append(",{ \"range\": {\"date\": {" + gte + "}}}");
			} else {
				request.append(",{ \"range\": {\"date\": {" + lte + "}}}");
			}

			request.append("]}},\"aggs\": {\"date\": {\"date_histogram\": {\"field\": \"date\",\"interval\": \"day\",\"format\": \"yyyy-MM-dd\"},\"aggs\": {\"vulns\": {\"sum\": {\"field\": \"count\"}}}}}}");

			String responseJson = PacHttpUtils.doHttpPost(
					urlToQuery.toString(), request.toString());
			JsonParser jsonParser = new JsonParser();
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonArray buckets = resultJson.get(AGGREGATIONS)
					.getAsJsonObject().get("date").getAsJsonObject()
					.get(BUCKETS).getAsJsonArray();
			if (buckets.size() > 0) {
				for (int i = 0; i < buckets.size(); i++) {
					Map<String, Object> trend = new HashMap<>();
					JsonObject bucket = (JsonObject) buckets.get(i);
					String date = bucket.get("key_as_string").getAsString();
					Long count = bucket.get(VULN).getAsJsonObject()
							.get(VALUE).getAsLong();
					trend.put("date", date);
					trend.put(COUNT, count);
					vulnTrendList.add(trend);
				}
			}
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityTrend from ES", e);
			throw e;
		}

		return vulnTrendList;
	}

	/**
	 * Gets the vulnerabilities distribution.
	 *
	 * @param assetGroup the asset group
	 * @param parentType the parent type
	 * @return the vulnerabilities distribution
	 * @throws Exception the exception
	 */
	public List<Map<String, Object>> getVulnerabilitiesDistribution(
			String assetGroup, String parentType) throws Exception {
		List<Map<String, Object>> vulnDistributions = new ArrayList<>();

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(parentType).append("/_search");
		String requestBody = "{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}]}},\"aggs\":{\"apps\":{\"terms\":{\"field\":\"tags.Application.keyword\",\"size\":1000},"
				+ "\"aggs\":{\"envs\":{\"terms\":{\"field\":\"tags.Environment.keyword\",\"size\":1000},\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},"
				+ "\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"S3\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":3}},{\"match\":{\"latest\":true}}]}},\"S4\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":4}},{\"match\":{\"latest\":true}}]}},\"S5\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":5}},{\"match\":{\"latest\":true}}]}}}}}}}}}}}}}";
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody);
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilitiesDistribution from ES", e);
			throw e;
		}

		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
				AGGREGATIONS).toString());
		JsonArray outerBuckets = aggsJson.getAsJsonObject("apps")
				.getAsJsonArray(BUCKETS);
		if (outerBuckets.size() > 0) {
			for (int i = 0; i < outerBuckets.size(); i++) {
				Map<String, Object> applist = new HashMap<>();
				String appName = outerBuckets.get(i).getAsJsonObject()
						.get("key").getAsString();
				JsonArray envs = outerBuckets.get(i).getAsJsonObject()
						.getAsJsonObject("envs").getAsJsonArray(BUCKETS);
				List<Map<String, Object>> envDetails = new ArrayList<>();
				if (envs.size() > 0) {
					for (int j = 0; j < envs.size(); j++) {
						String envName = envs.get(j).getAsJsonObject()
								.get("key").getAsString();
						List<Map<String, Object>> severityInfo = getSeverityInfo(
								envs.get(j).getAsJsonObject()
										.getAsJsonObject(VULN)
										.getAsJsonObject("NAME")
										.getAsJsonObject(BUCKETS), null);
						Map<String, Object> envSeverity = new HashMap<>();
						envSeverity.put("environment", envName);
						envSeverity.put(SEVERITY_INFO, severityInfo);
						envSeverity.put(
								VULNEREBILITIES,
								Integer.valueOf(severityInfo.get(0)
										.get(COUNT).toString())
										+ Integer.valueOf(severityInfo.get(ONE)
												.get(COUNT).toString())
										+ Integer.valueOf(severityInfo.get(TWO)
												.get(COUNT).toString()));
						envDetails.add(envSeverity);
					}
				}
				applist.put(APPS, appName);
				applist.put("applicationInfo", envDetails);
				vulnDistributions.add(applist);
			}
		}
		return vulnDistributions;
	}
	
	/**
	 * Gets the vulnerabilitysummary by resource id.
	 *
	 * @param resourceId the resource id
	 * @return the vulnerabilitysummary by resource id
	 */
	public Map<String, Object> getVulnerabilitysummaryByResourceId(
			String resourceId) {

		String index = "aws_onpremserver,aws_ec2";
		Map<String, Object> vulnSummary = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				index);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"_resourceid.keyword\":\"");
		requestBody.append(resourceId);
		requestBody
				.append("\"}},{\"terms\": {\"severitylevel\": [3,4,5]}}]}},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"S3\":{\"term\":{\"severitylevel\":\"3\"}},\"S4\":{\"term\":{\"severitylevel\":\"4\"}},\"S5\":{\"term\":{\"severitylevel\":\"5\"}}}}}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(
					"Error in getVulnerabilitysummaryByResourceId from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				"hits").toString());
    		vulnSummary.put(TOTAL, hitsJson.get(TOTAL).getAsLong());
    		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				AGGREGATIONS).toString());
    		try {
    			vulnSummary.put(
    					SEVERITY_INFO,
    					getSeverityInfo(aggsJson.getAsJsonObject("NAME")
    							.getAsJsonObject(BUCKETS), null));
    		} catch (Exception e) {
    			LOGGER.error("Error in getVulnerabilitysummaryByResourceId ", e);
    		}
		}
		return vulnSummary;

	}

	/**
	 * Gets the vulnerability details by resource id.
	 *
	 * @param resourceId the resource id
	 * @return the vulnerability details by resource id
	 */
	public List<Map<String, Object>> getVulnerabilityDetailsByResourceId(
			String resourceId) {

		List<Map<String, Object>> results = new ArrayList<>();
		Long totalDocs = (Long) getVulnerabilitysummaryByResourceId(resourceId)
				.get(TOTAL);
		StringBuilder urlToQueryBuffer = new StringBuilder(esUrl).append("/")
				.append("aws_ec2,aws_onpremserver");
		urlToQueryBuffer.append("/").append(VULN_INFO);
		urlToQueryBuffer.append("/").append(SEARCH).append(SCROLL)
				.append(ES_PAGE_SCROLL_TTL);

		String urlToQuery = urlToQueryBuffer.toString();
		String urlToScroll = new StringBuilder(esUrl).append("/")
				.append(SEARCH).append(SLASH_SCROLL).toString();

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel\":[3,4,5]}},{\"match\":{\"_resourceid.keyword\":\"");
		requestBody.append(resourceId);
		requestBody.append("\"}}]}}}");
		String request = requestBody.toString();
		String scrollId = null;
		for (int index = 0; index <= (totalDocs / ES_PAGE_SIZE); index++) {
			try {
				if (!Strings.isNullOrEmpty(scrollId)) {
					request = elasticSearchRepository.buildScrollRequest(
							scrollId, ES_PAGE_SCROLL_TTL);
					urlToQuery = urlToScroll;
				}
				String responseDetails = PacHttpUtils.doHttpPost(urlToQuery,
						request);
				scrollId = elasticSearchRepository
						.processResponseAndSendTheScrollBack(responseDetails,
								results);
			} catch (Exception e) {
				LOGGER.error("Error in getVulnerabilityDetailsByResourceId", e);
			}
		}
		return results;
	}

	/**
	 * Gets the severity info.
	 *
	 * @param countBucket the count bucket
	 * @param severity the severity
	 * @return the severity info
	 * @throws DataException the data exception
	 */
	private List<Map<String, Object>> getSeverityInfo(JsonObject countBucket,
			String severity){

		List<Map<String, Object>> severityInfo = new ArrayList<>();
		if (StringUtils.isEmpty(severity)) {
			Map<String, Object> severity3 = new HashMap<>();
			severity3.put(SEVEITY_LEVEL, THREE);
			severity3.put(SEVERITY, "S3");
			severity3.put(COUNT,
					countBucket.getAsJsonObject("S3").get(DOC_COUNT)
							.getAsLong());
			severity3.put(VULN_COUNT, countBucket
					.getAsJsonObject("S3").get(DOC_COUNT).getAsLong());
			Map<String, Object> severity4 = new HashMap<>();
			severity4.put(SEVEITY_LEVEL, FOUR);
			severity4.put(SEVERITY, "S4");
			severity4.put(COUNT,
					countBucket.getAsJsonObject("S4").get(DOC_COUNT)
							.getAsLong());
			severity4.put(VULN_COUNT, countBucket
					.getAsJsonObject("S4").get(DOC_COUNT).getAsLong());
			Map<String, Object> severity5 = new HashMap<>();
			severity5.put(SEVEITY_LEVEL, FIVE);
			severity5.put(COUNT,
					countBucket.getAsJsonObject("S5").get(DOC_COUNT)
							.getAsLong());
			severity5.put(SEVERITY, "S5");
			severity5.put(VULN_COUNT, countBucket
					.getAsJsonObject("S5").get(DOC_COUNT).getAsLong());
			severityInfo.add(severity3);
			severityInfo.add(severity4);
			severityInfo.add(severity5);
		} else {
			Map<String, Object> severityMap = new HashMap<>();
			severityMap.put(SEVEITY_LEVEL, Integer.valueOf(severity));
			severityMap.put(COUNT, countBucket
					.getAsJsonObject("S" + severity).get(DOC_COUNT)
					.getAsLong());
			severityMap.put(SEVERITY, "S" + severity);
			severityMap.put(VULN_COUNT,
					countBucket.getAsJsonObject("S" + severity)
							.get(DOC_COUNT).getAsLong());
			severityInfo.add(severityMap);
		}

		return severityInfo;
	}

	/**
	 * Fetch exec director apps.
	 *
	 * @return the list
	 * @throws Exception the exception
	 */
	public List<Map<String, Object>> fetchExecDirectorApps() throws Exception {
	    Map<String, Object> mustFilter = new HashMap<>();
	    mustFilter.put(Constants.LATEST, Constants.TRUE);
		return elasticSearchRepository.getDataFromES("aws_apps", "apps", mustFilter,
				null, null,Arrays.asList("appTag", "director", "executiveSponsor"), null);

	}

	/**
	 * Gets the unique host.
	 *
	 * @param assetGroup the asset group
	 * @return the unique host
	 */
	public Map<String, Object> getUniqueHost(String assetGroup,String severity) {

		Map<String, Object> uniqueHost = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":["+severity+"]}}]}}}}]}},\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},"
				+ "\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":["+severity+"]}}]}},"
				+ "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel\",\"size\":5},"
				+ "\"aggs\":{\"unique-host\":{\"cardinality\":{\"field\":\"_resourceid.keyword\",\"precision_threshold\":40000}}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}
		
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		
    		JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    HITS).toString());
    		long total = hitsJson.get(TOTAL).getAsLong();
    		uniqueHost.put(TOTAL,total);
    		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				AGGREGATIONS).toString());
    		JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").getAsJsonObject(SEVERITY)
    				.getAsJsonArray(BUCKETS);
    		if (buckets.size() > 0) {
    			for (int i = 0; i < buckets.size(); i++) {
    				uniqueHost.put(buckets.get(i).getAsJsonObject().get("key")
    						.toString(),
    						buckets.get(i).getAsJsonObject().get("unique-host")
    								.getAsJsonObject().get(VALUE).getAsLong());
    			}
    		}
		}
		return uniqueHost;
	}

	/**
	 * Gets the unique vuln.
	 *
	 * @param assetGroup the asset group
	 * @return the unique vuln
	 */
	public Map<String, Object> getVulnInfo(String assetGroup,String severity) {

		Map<String, Object> vulnInfo = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
		        "{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":["+severity+"]}}]}}}}]}},\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},"
		                + "\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":["+severity+"]}}]}},"
		                + "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel\",\"size\":5},"
		                + "\"aggs\":{\"unique-qid\":{\"cardinality\":{\"script\":\"doc['qid'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}}}");
		
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}
		
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				AGGREGATIONS).toString());
    		long total =  aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").get(DOC_COUNT).getAsLong();
    		vulnInfo.put(TOTAL, total)  ;     
    		JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").getAsJsonObject(SEVERITY)
                    .getAsJsonArray(BUCKETS);
    		
    		Map<String,Object> sevInfo;
    		if (buckets.size() > 0) {
    			for (int i = 0; i < buckets.size(); i++) {
    			    String sevKey = buckets.get(i).getAsJsonObject().get("key")
                            .toString();
    			    sevInfo = new HashMap<>();
    			    sevInfo.put(SEVERITY, sevKey);
    			    sevInfo.put(UNIQUE_VULN_COUNT,buckets.get(i).getAsJsonObject().get(UNIQUE_QID)
                                    .getAsJsonObject().get(VALUE).getAsLong());
    			    sevInfo.put(VULN_COUNT,buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
    			    vulnInfo.put(sevKey,sevInfo);
    			}
    		}
		}
		return vulnInfo;
	}

	/**
	 * Gets the unique app.
	 *
	 * @param assetGroup the asset group
	 * @return the unique app
	 */
	public Map<String, Object> getUniqueApp(String assetGroup) {

		Map<String, Object> uniqueApp = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append("_search?filter_path=aggregations");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"_entity\":true}}]}},"
						+ "\"aggs\":{\"severity\":{\"filters\":{\"filters\":{"
						+ "\"S3\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel\":3}}]}}}},"
						+ "\"S4\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel\":4}}]}}}},"
						+ "\"S5\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel\":5}}]}}}}}},"
						+ "\"aggs\":{\"NAME\":{\"cardinality\":{\"field\":\"tags.Application.keyword\",\"precision_threshold\": 40000}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				AGGREGATIONS).toString());
    		JsonObject buckets = aggsJson.getAsJsonObject(SEVERITY)
    				.getAsJsonObject(BUCKETS);
    		for (int i = 3; i <= 5; i++) {
    			uniqueApp.put(
    					String.valueOf(i),
    					buckets.get("S"+i).getAsJsonObject()
    							.get("NAME").getAsJsonObject().get(VALUE)
    							.getAsLong());
    		}
		}
		return uniqueApp;
	}

	/**
	 * Gets the aging summary.
	 *
	 * @param assetGroup the asset group
	 * @return the aging summary
	 */
	public List<Map<String, Object>> getAgingSummary(String assetGroup) {

		List<Map<String, Object>> agingSummary = new ArrayList<>();
		Map<String, Double> avgAgingMap = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel\":[3,4,5]}}]}},"
						+ "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel\",\"size\":10},\"aggs\":{\"aging\":{\"avg\":{\"field\":\"_vulnage\"}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAgingSummary from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
    				AGGREGATIONS).toString());
    		JsonArray buckets = aggsJson.getAsJsonObject(SEVERITY)
    				.getAsJsonArray(BUCKETS);
    		if (buckets.size() > 0) {
    			for (int i = 0; i < buckets.size(); i++) {
    				avgAgingMap.put(
    						buckets.get(i).getAsJsonObject().get("key").toString(),
    						Math.floor(buckets.get(i).getAsJsonObject()
    								.get(AGING).getAsJsonObject().get(VALUE)
    								.getAsDouble()));
    			}
    		}
    
    		avgAgingMap.forEach((severity, avg) -> {
    			Map<String, Object> sevInfo = new HashMap<>();
    			sevInfo.put(SEVERITY, "S" + severity);
    			sevInfo.put("days", avg);
    			agingSummary.add(sevInfo);
    		});
		}
		return agingSummary;
	}

	/**
	 * Gets the aging by application.
	 *
	 * @param assetGroup the asset group
	 * @param parentType the parent type
	 * @param severity the severity
	 * @return the aging by application
	 * @throws Exception the exception
	 */
	public List<Map<String, Object>> getAgingByApplication(String assetGroup,
			String parentType, String severity) throws Exception {

		List<Map<String, Object>> vulnApplications = new ArrayList<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				assetGroup);
		urlToQuery.append("/").append(parentType);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}]}},\"aggs\":{\"apps\":{\"terms\":{\"field\":\"tags.Application.keyword\",\"size\":10000},"
						+ "\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"");
		if (StringUtils.isNotEmpty(severity)) {
			requestBody.append("S").append(severity);
			requestBody.append("\":{\"bool\":{\"must\":[ {\"match\":{\"latest\":true}},{\"term\":{\"severitylevel\":")
					.append(severity).append("}}]}}");
		} else {
			requestBody
					.append("S3\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":3}},{\"match\":{\"latest\":true}}]}},\"S4\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":4}},{\"match\":{\"latest\":true}}]}},\"S5\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel\":5}},{\"match\":{\"latest\":true}}]}}");
		}
		requestBody
				.append("}},\"aggs\":{\"aging\":{\"sum\":{\"field\":\"_vulnage\"}}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAgingByApplication from ES", e);
			throw e;
		}
		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
				AGGREGATIONS).toString());
		JsonArray outerBuckets = aggsJson.getAsJsonObject("apps")
				.getAsJsonArray(BUCKETS);
		if (outerBuckets.size() > 0) {
			for (int i = 0; i < outerBuckets.size(); i++) {
				String appName = outerBuckets.get(i).getAsJsonObject()
						.get("key").getAsString();
				List<Map<String, Object>> agingInfo = getAgingInfo(outerBuckets
						.get(i).getAsJsonObject().getAsJsonObject(VULN)
						.getAsJsonObject("NAME").getAsJsonObject(BUCKETS),
						severity);
				Map<String, Object> applicationInfo = new HashMap<>();
				applicationInfo.put(APPS, appName);
				applicationInfo.put("severityinfo", agingInfo);
				vulnApplications.add(applicationInfo);
			}
		}
		return vulnApplications;
	}

	/**
	 * Gets the aging info.
	 *
	 * @param countBucket the count bucket
	 * @param severity the severity
	 * @return the aging info
	 * @throws DataException the data exception
	 */
	private List<Map<String, Object>> getAgingInfo(JsonObject countBucket,
			String severity) throws DataException {

		List<Map<String, Object>> severityInfo = new ArrayList<>();
		if (StringUtils.isEmpty(severity)) {
			Map<String, Object> severity3 = new HashMap<>();
			severity3.put(SEVEITY_LEVEL, 3);
			severity3.put(SEVERITY, "S3");
			if (countBucket.getAsJsonObject("S3").get(DOC_COUNT).toString()
					.equals(ZERO)) {
				severity3.put("days", 0);
				severity3.put(COUNT, 0);
			} else {
				severity3.put(COUNT,
						countBucket.getAsJsonObject("S3").get(DOC_COUNT)
								.getAsDouble());
				severity3.put(
						"days",
						Math.floor(countBucket.getAsJsonObject("S3")
								.get(AGING).getAsJsonObject().get(VALUE)
								.getAsDouble()));
			}
			Map<String, Object> severity4 = new HashMap<>();
			severity4.put(SEVEITY_LEVEL, 4);
			severity4.put(SEVERITY, "S4");
			if (countBucket.getAsJsonObject("S4").get(DOC_COUNT).toString()
					.equals(ZERO)) {
				severity4.put("days", 0);
				severity4.put(COUNT, 0);
			} else {
				severity4.put(COUNT,
						countBucket.getAsJsonObject("S4").get(DOC_COUNT)
								.getAsDouble());
				severity4.put("days",
						countBucket.getAsJsonObject("S4").get(AGING)
								.getAsJsonObject().get(VALUE).getAsDouble());
			}
			Map<String, Object> severity5 = new HashMap<>();
			severity5.put(SEVEITY_LEVEL, 5);
			severity5.put(SEVERITY, "S5");
			if (countBucket.getAsJsonObject("S5").get(DOC_COUNT).toString()
					.equals(ZERO)) {
				severity5.put(COUNT, 0);
				severity5.put("days", 0);
			} else {
				severity5.put(COUNT,
						countBucket.getAsJsonObject("S5").get(DOC_COUNT)
								.getAsDouble());
				severity5.put("days",
						countBucket.getAsJsonObject("S5").get(AGING)
								.getAsJsonObject().get(VALUE).getAsDouble());
			}
			severityInfo.add(severity3);
			severityInfo.add(severity4);
			severityInfo.add(severity5);
		} else {
			Map<String, Object> severityMap = new HashMap<>();
			severityMap.put(SEVEITY_LEVEL, Integer.valueOf(severity));
			severityMap.put(SEVERITY, "S" + severity);
			if (countBucket.getAsJsonObject("S" + severity).get(DOC_COUNT)
					.toString().equals(ZERO)) {
				severityMap.put("days", 0);
				severityMap.put(COUNT, 0);
			} else {
				severityMap.put(
						COUNT,
						countBucket.getAsJsonObject("S" + severity)
								.get(DOC_COUNT).getAsDouble());
				severityMap.put("days",
						countBucket.getAsJsonObject("S" + severity)
								.get(AGING).getAsJsonObject().get(VALUE)
								.getAsDouble());
			}
			severityInfo.add(severityMap);
		}

		return severityInfo;
	}

	/**
	 * Gets the total qualys host count.
	 *
	 * @param index the index
	 * @param vulnType the vuln type
	 * @return the total qualys host count
	 * @throws DataException the data exception
	 */
	public long getTotalQualysHostCount(String index, String vulnType)
			throws DataException {
	    StringBuilder urlToQuery = new StringBuilder(esUrl).append("/")
                .append(index).append("/").append(vulnType).append("/")
                .append(UNDERSCORE_COUNT);
        StringBuilder requestBody = new StringBuilder("{\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"qualysinfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}}]}}}}]}}}");
        try {
            String responseDetails = PacHttpUtils.doHttpPost(
                    urlToQuery.toString(), requestBody.toString());
            JsonObject responseObj = (JsonObject) new JsonParser().parse(responseDetails);
            return (long) responseObj.get("count").getAsLong();
        } catch (Exception e) {
            LOGGER.error("Error in getTotalQualysAssetCount", e);
            throw new DataException(e);
        }
	}

	/**
	 * Gets the vulnerability by qid.
	 *
	 * @param qid the qid
	 * @return the vulnerability by qid
	 */
	public Map<String, Object> getVulnerabilityByQid(String qid) {

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
				"qualys-kb/kb/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"query\":{\"bool\":{\"must\":[{\"term\":{\"latest\":\"true\"}},{\"term\":{\"qid\":\"");
		requestBody.append(qid);
		requestBody.append("\"}}]}}}");   

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
					requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityByQid from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		Map<String, Object> vuln = new HashMap<>();
		if(StringUtils.isNotEmpty(responseJson)) {
    		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
    		JsonArray hits = resultJson.get("hits").getAsJsonObject().get("hits")
    				.getAsJsonArray();
    		if (hits.size() > 0) {
    			for (int i = 0; i < hits.size(); i++) {
    				JsonObject obj = (JsonObject) hits.get(i);
    				JsonObject sourceJson = (JsonObject) obj.get("_source");
    				if (sourceJson != null) {
    					vuln = new Gson().fromJson(sourceJson,
    							new TypeToken<Map<String, Object>>() {
    							}.getType());
    					vuln.remove("latest");
    					vuln.remove("_loadDate");
    				}
    			}
    		}
		}
		return vuln;
	}
	
	/**
	 * Gets the unique vuln with parent.
	 *
	 * @param assetGroup the asset group
	 * @param severitylevel the severitylevel
	 * @param parentType the parent type
	 * @return the vulnerability by qid
	 * @throws DataException the data exception
	 */
	public Map<String, Object> getDistributionSummaryByInfraType(String assetGroup, String severitylevel, String parentType) throws DataException {

        Map<String, Object> infraInfo = new HashMap<>();
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(parentType);
        urlToQuery.append("/").append(SEARCH);
        StringBuilder requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},"
                + "{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},"
                + "{\"terms\":{\"severitylevel\":[%s]}}]}}}}]}},\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},"
                + "\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}},"
                + "\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid'].toString().replace('.0','')\",\"precision_threshold\":40000}}}}}}}}");
        String requestJson = String.format(requestBody.toString(), severitylevel,severitylevel);
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestJson);
        } catch (Exception e) {
            LOGGER.error("Error in getDistributionSummaryByInfraType", e);
            throw new DataException(e);
        }
        JsonParser jsonParser = new JsonParser();
        if(StringUtils.isNotEmpty(responseJson)) {
            JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
            JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    HITS).toString());
            JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    AGGREGATIONS).toString());
            long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
            long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(DOC_COUNT).getAsLong();
            long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();
            
            infraInfo.put(TOTAL_VULN_ASSETS,totalVulnerableAssets);
            infraInfo.put(VULNEREBILITIES,vulnerabilities);
            infraInfo.put(UNIQUE_VULN_COUNT,uniqueVulnCount);
        }
        return infraInfo;
    }
	
	/**
	 * Gets the prod info by env.
	 *
	 * @param assetGroup the asset group
	 * @param severitylevel the severitylevel
	 * @return the prod info by env
	 */
	public Map<String,Long> getProdInfoByEnv(String assetGroup, String severitylevel) {
	    
	    Map<String, Long> prodInfo = new HashMap<>();
	    StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(SEARCH);
        
        StringBuilder requestbody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},");
        requestbody.append("{\"terms\":{\"severitylevel\":[%s]}}]}}}}],")
                  .append("\"should\":[{\"prefix\":{\"tags.Environment.keyword\":\"Production\"}},")
                  .append( "{\"prefix\":{\"tags.Environment.keyword\":\"production\"}},")
                  .append( "{\"prefix\":{\"tags.Environment.keyword\":\"Prd\"}},")
                  .append( "{\"prefix\":{\"tags.Environment.keyword\":\"prd\"}},")
                  .append("{\"prefix\":{\"tags.Environment.keyword\":\"PRD\"}},")
                  .append( "{\"prefix\":{\"tags.Environment.keyword\":\"Prod\"}},")
                  .append("{\"prefix\":{\"tags.Environment.keyword\":\"PROD\"}}],")
                  .append("\"minimum_should_match\":1}},")
                  .append( "\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},")
                  .append( "\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}},")
                  .append( "\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}");
        String requestJson = String.format(requestbody.toString(), severitylevel,severitylevel);
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestJson);
        } catch (Exception e) {
            LOGGER.error("Error in getProdInfoByEnv", e);
        }
    
        JsonParser jsonParser = new JsonParser();
        if(StringUtils.isNotEmpty(responseJson)) {
            JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
            JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    HITS).toString());
            JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    AGGREGATIONS).toString());
            long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
            long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(DOC_COUNT).getAsLong();
            long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();
            
            prodInfo.put(TOTAL_VULN_ASSETS,totalVulnerableAssets);
            prodInfo.put(VULNEREBILITIES,vulnerabilities);
            prodInfo.put(UNIQUE_VULN_COUNT,uniqueVulnCount);
        }
        
        return prodInfo;
        
	}
	
	/**
	 * Gets the non prod info by env.
	 *
	 * @param assetGroup the asset group
	 * @param severitylevel the severitylevel
	 * @return the non prod info by env
	 */
	public Map<String,Long> getNonProdInfoByEnv(String assetGroup, String severitylevel) {
        
        Map<String, Long> nonProdInfo = new HashMap<>();
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(SEARCH);
        
        StringBuilder requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},");
        requestBody.append("{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}}}}],")
            .append("\"must_not\":[")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"Production\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"production\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"Prd\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"prd\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"PRD\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"Prod\"}},")
            .append("{\"prefix\":{\"tags.Environment.keyword\":\"PROD\"}}]}},")
            .append("\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}},")
            .append("\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}");
        String requestJson = String.format(requestBody.toString(), severitylevel,severitylevel);
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestJson);
        } catch (Exception e) {
            LOGGER.error("Error in getNonProdInfoByEnv", e);
        }
        
        JsonParser jsonParser = new JsonParser();
        if(StringUtils.isNotEmpty(responseJson)) {
            JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
            JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    HITS).toString());
            JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                    AGGREGATIONS).toString());
            long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
            long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(DOC_COUNT).getAsLong();
            long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();
            
            nonProdInfo.put(TOTAL_VULN_ASSETS,totalVulnerableAssets);
            nonProdInfo.put(VULNEREBILITIES,vulnerabilities);
            nonProdInfo.put(UNIQUE_VULN_COUNT,uniqueVulnCount);
        }
        return nonProdInfo;
        
    }
	
    /**
     * Gets the distribution summary by vuln type.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the distribution summary by vuln type
     * @throws DataException the data exception
     */
    public List<Map<String, Object>> getDistributionSummaryByVulnType(String assetGroup, String severity) throws DataException {
        
        List<Map<String,Object>> distributionList = new ArrayList<>();
        long totalVulnCount = 0;
        Map<String,Object> infoOS = new HashMap<>();
        infoOS.put("category", "OS");
        infoOS.put(TOTAL_VULN_ASSETS, 0);
        infoOS.put(VULNEREBILITIES, 0);
        infoOS.put(UNIQUE_VULN_COUNT,0);
                
        Map<String,Object> infoApp = new HashMap<>();
        infoApp.put("category", "Application");
        infoApp.put(TOTAL_VULN_ASSETS, 0);
        infoApp.put(VULNEREBILITIES, 0);
        infoApp.put(UNIQUE_VULN_COUNT,0);
        
        
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(SEARCH);
        StringBuilder requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},")
                .append( "{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}}}}]}},")
                .append("\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}},")
                .append("\"aggs\":{\"classification\":{\"terms\":{\"field\":\"classification.keyword\",\"size\":10},\"aggs\":{\"resources\":{\"cardinality\":{\"field\":\"_resourceid.keyword\",\"precision_threshold\":40000}}}}}}}}}}");
            
        
        String requestJson = String.format(requestBody.toString(), severity,severity);
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestJson);
        } catch (Exception e) {
            LOGGER.error("Error in getVulnerabilitySummaryByClassification from ES", e);
            throw new DataException(e);
        }
      
        JsonParser jsonParser = new JsonParser();
        JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
        JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                AGGREGATIONS).toString());
        JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").getAsJsonObject("classification")
                .getAsJsonArray(BUCKETS);
        if (buckets.size() > 0) {
            for (int i = 0; i < buckets.size(); i++) {
                totalVulnCount += buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong();
                if(buckets.get(i).getAsJsonObject().get("key")
                        .toString().replace("\"", "").equals("OS")) {
                    infoOS.put(TOTAL_VULN_ASSETS, buckets.get(i).getAsJsonObject().get("resources").getAsJsonObject().get(VALUE).getAsLong());
                    infoOS.put(VULNEREBILITIES, buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
                } else {
                    infoApp.put(TOTAL_VULN_ASSETS, buckets.get(i).getAsJsonObject().get("resources").getAsJsonObject().get(VALUE).getAsLong());
                    infoApp.put(VULNEREBILITIES, buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
                }
            }
        }
        
        requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},")
                .append( "{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}}}}]}},")
                .append("\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[%s]}}]}},")
                .append("\"aggs\":{\"classification\":{\"terms\":{\"field\":\"classification.keyword\",\"size\":10},\"aggs\":{\"unique-qid\":{\"cardinality\":{\"script\":\"doc['qid'].toString().replace('.0','')\",\"precision_threshold\":40000}}}}}}}}}}");
        
        requestJson = String.format(requestBody.toString(), severity,severity);
        responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestJson);
        } catch (Exception e) {
            LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
            throw new DataException(e);
        }
        
        resultJson = (JsonObject) jsonParser.parse(responseJson);
        aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                AGGREGATIONS).toString());
        buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").getAsJsonObject("classification")
                .getAsJsonArray(BUCKETS);
        if (buckets.size() > 0) {
            for (int i = 0; i < buckets.size(); i++) {
                if(buckets.get(i).getAsJsonObject().get("key")
                        .toString().replace("\"", "").equals("OS")) {
                    infoOS.put(UNIQUE_VULN_COUNT, buckets.get(i).getAsJsonObject().get(UNIQUE_QID)
                            .getAsJsonObject().get(VALUE).getAsLong());
                } else {
                    infoApp.put(UNIQUE_VULN_COUNT, buckets.get(i).getAsJsonObject().get(UNIQUE_QID)
                            .getAsJsonObject().get(VALUE).getAsLong());
                }
            }
        }
        
        if(totalVulnCount > 0){
            distributionList.add(infoOS);
            distributionList.add(infoApp);
        }
        double contribution = HUNDRED;
        for(int i=0;i<distributionList.size();i++) {
            Map<String,Object> info = distributionList.get(i);
            if(totalVulnCount > 0){
                double contributionPercent = Math.floor((Double.valueOf(info.get(VULNEREBILITIES).toString())/totalVulnCount)*HUNDRED);
                if(i== distributionList.size()-1){
                    info.put("contribution", contribution);
                }else{
                    info.put("contribution", contributionPercent);
                    contribution = contribution-contributionPercent;
                }
            }
        }
        return distributionList;
    }
    
    /**
     * Gets the all qid by AG.
     *
     * @param assetGroup the asset group
     * @param severity the severity
     * @return the all qid by AG
     * @throws DataException the data exception
     */
    public Map<String,Object> getAllQidByAG(String assetGroup, String severity) throws DataException {
        
        Map<String,Object> qids = new HashMap<>();
       
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(VULN_INFO);
        urlToQuery.append("/").append(SEARCH);
        StringBuilder requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel\":[");
        requestBody.append(severity);
        requestBody.append("]}}]}},\"aggs\":{\"qid\":{\"terms\":{\"script\":\"(doc['qid'].value+'~').replace('.0','')+doc['title.keyword'].value.toLowerCase()+'~'+doc['classification.keyword'].value\",\"size\":100000}}}}");
        
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestBody.toString());
        } catch (Exception e) {
            LOGGER.error("Error in getAllQidByAG from ES", e);
            throw new DataException(e);
        }
        JsonParser jsonParser = new JsonParser();
        JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
        JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                AGGREGATIONS).toString());
        JsonArray buckets = aggsJson.getAsJsonObject("qid")
                .getAsJsonArray(BUCKETS);
        if (buckets.size() > 0) {
            for (int i = 0; i < buckets.size(); i++) {
                qids.put(buckets.get(i).getAsJsonObject().get("key")
                        .toString().replace("\"", ""), buckets.get(i).getAsJsonObject().get(DOC_COUNT));
            }
        }
        return qids;
    }
    
    /**
     * Gets the apps by severity.
     *
     * @param assetGroup the asset group
     * @param parentType the parent type
     * @param severity the severity
     * @return the apps by severity
     * @throws Exception the exception
     */
    public Map<String, Long> getAppsBySeverity(String assetGroup,
            String parentType, String severity) throws Exception {

        Map<String,Long> appDetails = new HashMap<>();
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                assetGroup);
        urlToQuery.append("/").append(parentType);
        urlToQuery.append("/").append(SEARCH);

        StringBuilder requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}]}},"
                + "\"aggs\":{\"apps\":{\"terms\":{\"field\":\"tags.Application.keyword\",\"size\":10000},"
                + "\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"severity\":{\"terms\":{\"severitylevel\":[");
        requestBody.append(severity);
        requestBody.append("]}}}}}}}}}}}");
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestBody.toString());
        } catch (Exception e) {
            LOGGER.error("Error in getAppsBySeverity from ES", e);
            throw e;
        }
        JsonParser jsonParser = new JsonParser();
        JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
        JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(
                AGGREGATIONS).toString());
        JsonArray buckets = aggsJson.getAsJsonObject("apps")
                .getAsJsonArray(BUCKETS);
        if (buckets.size() > 0) {
            for (int i = 0; i < buckets.size(); i++) {
                appDetails.put(buckets.get(i).getAsJsonObject()
                .get("key").getAsString(),buckets.get(i).getAsJsonObject().getAsJsonObject("vulns")
                .getAsJsonObject("NAME").getAsJsonObject("buckets").getAsJsonObject("severity").get(DOC_COUNT).getAsLong());
            }
        }
        return appDetails;
    }
    
    /**
     * Creates the trend annotation.
     *
     * @param request the request
     * @return true, if successful
     * @throws JsonProcessingException the json processing exception
     */
    public boolean createTrendAnnotation(TrendNote request) throws JsonProcessingException {
        
        SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");
        SimpleDateFormat dateformatId = new SimpleDateFormat("yyyyMMdd");
        String assetGroup;
        if(StringUtils.isBlank(request.getAg())) {
            assetGroup = "";
        } else {
            assetGroup = request.getAg();
        }
        Date date = request.getDate();
        Map<String,Object> payLoad = new HashMap<>();
        payLoad.put("ag", assetGroup);
        payLoad.put("note", request.getNote());
        payLoad.put("date", dateformat.format(date));
        if(StringUtils.isEmpty(assetGroup)) {
            payLoad.put(NOTE_ID, dateformatId.format(date));
        } else {
            payLoad.put(NOTE_ID, assetGroup+"_"+dateformatId.format(date));
        }
        
        
        List<Map<String, Object>> docs = new ArrayList<>();
        docs.add(payLoad);
        createIndex("assetgroup_annotations");
        return uploadData("assetgroup_annotations", "annotations", docs, NOTE_ID);
    }
    
    /**
     * Creates the index.
     *
     * @param indexName the index name
     */
    public void createIndex(String indexName){
        if(!indexExists(indexName)){
            String payLoad = "{\"settings\": { \"index.mapping.ignore_malformed\": true }}";
            invokeAPI("PUT",indexName,payLoad);
        }
    }
    
    private boolean indexExists(String indexName){
        Response response = invokeAPI("HEAD",indexName,null);
        if(response!=null){
            return response.getStatusLine().getStatusCode() == 200?true:false;
        }
        return false;
    }
    
    private boolean uploadData(String index, String type, List<Map<String, Object>> docs, String idKey) {
        String actionTemplate = "{ \"index\" : { \"_index\" : \"%s\", \"_type\" : \"%s\", \"_id\" : \"%s\"} }%n";

        LOGGER.info("*********UPLOADING*** " + type);
        if (null != docs && !docs.isEmpty()) {
            StringBuilder bulkRequest = new StringBuilder();
            int i = 0;
            for (Map<String, Object> doc : docs) {
                if (doc != null) {
                    String id = doc.get(idKey).toString();
                    StringBuilder docStrBuilder = new StringBuilder(createESDoc(doc));

                    if (docStrBuilder != null) {
                        bulkRequest.append(String.format(actionTemplate, index, type, id));
                        bulkRequest.append(docStrBuilder + "\n");
                    }
                    i++;
                    if (i % Constants.THOUSAND == 0
                            || bulkRequest.toString().getBytes().length
                                    / (Constants.THOUSAND_TWENTY_FOUR * Constants.THOUSAND_TWENTY_FOUR) > Constants.FIVE) {
                        LOGGER.info("Uploaded" + i);
                        Response resp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
                        try {
                            String responseStr = "";
                            if(null != resp) {
                                responseStr = EntityUtils.toString(resp.getEntity());
                            }
                            if (responseStr.contains("\"errors\":true")) {
                                Response retryResp = invokeAPI("POST", "/_bulk?refresh=true",
                                        bulkRequest.toString());
                                String retryResponse = "";
                                if(null != retryResp) {
                                    retryResponse = EntityUtils.toString(retryResp.getEntity());
                                }   
                                if (retryResponse.contains("\"errors\":true")) {
                                    LOGGER.error(retryResponse);
                                }
                            }
                        } catch (Exception e) {
                            LOGGER.error("Bulk upload failed",e);
                            return false;
                        }
                        bulkRequest = new StringBuilder();
                    }
                }
            }
            if (bulkRequest.length() > 0) {
                LOGGER.info("Uploaded" + i);
                Response resp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
                try {
                    String responseStr = "";
                    if(null != resp) {
                        responseStr = EntityUtils.toString(resp.getEntity());
                    }
                    if (responseStr.contains("\"errors\":true")) {
                        Response retryResp = invokeAPI("POST", "/_bulk?refresh=true",
                                bulkRequest.toString());
                        String retryResponse = "";
                        if(null != retryResp) {
                            retryResponse = EntityUtils.toString(retryResp.getEntity());
                        }
                        
                        if (retryResponse.contains("\"errors\":true")) {
                            LOGGER.error(retryResponse);
                        }
                    }
                    if(null != resp) {
                        return resp.getStatusLine().getStatusCode() == 200 ? true : false;
                    } else {
                        return false;
                    }
                } catch (Exception e) {
                    LOGGER.error("Bulk upload failed",e);
                    return false;
                }
            }
        }
        return true;
    }

    private String createESDoc(Map<String, ?> doc) {
        ObjectMapper objMapper = new ObjectMapper();
        String docJson = "{}";
        try {
            docJson = objMapper.writeValueAsString(doc);
        } catch (JsonProcessingException e) {
            LOGGER.error("Error in createESDoc" , e);
        }
        return docJson;
    }
    
    private Response invokeAPI(String method, String endpoint, String payLoad) {
        HttpEntity entity = null;
        try {
            if (payLoad != null) {
                entity = new NStringEntity(payLoad, ContentType.APPLICATION_JSON);
            }
            return getRestClient().performRequest(method, endpoint, Collections.<String, String>emptyMap(), entity);
        } catch (IOException e) {
            LOGGER.error("Error in invokeAPI" , e);
        }
        return null;
    }

    private RestClient getRestClient() {
        if (restClient == null) {
            restClient = RestClient.builder(new HttpHost(updateESHost, updateESPort)).build();
        }
        return restClient;
    }

    /**
     * Gets the trend annotations.
     *
     * @param ag the ag
     * @param from the from
     * @return the trend annotations
     */
    public List<Map<String, Object>> getTrendAnnotations(String ag,Date from) {
        
        List<Map<String, Object>> notes = new ArrayList<>();
        SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");
        
        StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(
                "assetgroup_annotations/annotations/_search");
        StringBuilder requestBody = new StringBuilder("{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"range\":{\"date\":{\"gte\":\"");
        requestBody.append(dateformat.format(from));
        requestBody.append("\",\"lte\":\"");
        requestBody.append(dateformat.format(new Date()));
        requestBody.append("\",\"format\":\"yyyy-MM-dd\"}}}");
        requestBody.append(",{\"terms\":{\"ag.keyword\":[\"\",\"");
        requestBody.append(ag).append("\"]}}]}}}");
        
        String responseJson = "";
        try {
            responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(),
                    requestBody.toString());
        } catch (Exception e) {
            LOGGER.error("Error in getTrendAnnotations from ES", e);
        }
        JsonParser jsonParser = new JsonParser();
        if (StringUtils.isNotEmpty(responseJson)) {
            JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
            JsonArray hits = resultJson.get("hits").getAsJsonObject().get("hits")
                    .getAsJsonArray();
            Map<String, Object> note ;
            if (hits.size() > 0) {
                for (int i = 0; i < hits.size(); i++) {
                    JsonObject obj = (JsonObject) hits.get(i);
                    JsonObject sourceJson = (JsonObject) obj.get("_source");
                    if (sourceJson != null) {
                        note = new Gson().fromJson(sourceJson,
                                new TypeToken<Map<String, Object>>() {
                                }.getType());
                        notes.add(note);
                    }
                }
            }
        }
        return notes;
    }
    
    /**
     * Delete trend annotation.
     *
     * @param noteId the note id
     * @return true, if successful
     */
    public boolean deleteTrendAnnotation(String noteId) {
       boolean result = false;
       try {
           result = invokeAPI("POST", "assetgroup_annotations/annotations/_delete_by_query?refresh&q=_id:"+noteId, null).getStatusLine().getStatusCode() == 200 ;
       } catch(Exception e) {
           LOGGER.error("Error in deleteTrendAnnotation ",e);
       }
       return result;
    }
    
    /**
     * Gets the data from pacman RDS.
     *
     * @param query the query
     * @return the data from pacman RDS
     */
    public List<Map<String, Object>> getDataFromPacmanRDS(String query) {
        return rdsRepository.getDataFromPacman(query);
    }
}
